{"version":3,"sources":["uni-app:///main.js",null,"webpack:///G:/PHP_dev/340-paopaoji/V3/paopao-v3-uinapp/pages/tabBar/home.vue?10d6","webpack:///G:/PHP_dev/340-paopaoji/V3/paopao-v3-uinapp/pages/tabBar/home.vue?8742","webpack:///G:/PHP_dev/340-paopaoji/V3/paopao-v3-uinapp/pages/tabBar/home.vue?d947","uni-app:///pages/tabBar/home.vue","webpack:///G:/PHP_dev/340-paopaoji/V3/paopao-v3-uinapp/pages/tabBar/home.vue?a74e","webpack:///G:/PHP_dev/340-paopaoji/V3/paopao-v3-uinapp/pages/tabBar/home.vue?7a86"],"names":["wx","__webpack_require_UNI_MP_PLUGIN__","__webpack_require__","createPage","Page","shoot","laser","laser_2","boom","warning","name","components","BulletRechargeDialog","WeaponSwitchDialog","MyPrizesDialog","PowerReferenceDialog","FeedbackDialog","RechargeRulesDialog","Reward","BulletWarningDialog","HpTopAlert","CloudBackgroundLight","CloudBackgroundBlack","mixins","data","userInfo","coin","localCoin","listData","hpConfig","warningThreshold","initialDamageBonus","initialShotsCount","initialDamageTarget","warnedFishIds","fishList","bullets","cannonAngle","gameArea","width","height","minX","maxX","minY","maxY","storageKeys","localHp","maxBullets","moveInterval","lastFrameTime","fps","frameInterval","hitEffects","consecutiveShots","lastShotTime","consecutiveBonus","sounds","isAudioLoaded","coinList","checkTimer","cancelTimer","pendingBulletCost","lastConsumeTime","consumeTimer","selectedFish","fireCooldown","gameLoopId","collisionCheckInterval","lastCollisionCheck","bulletSpeeds","normal","shotgun","bulletDamages","consecutiveHitBonus","lastHitTime","consecutiveHits","rapidFireBonus","lastFireTime","rapidFireWindow","targetFish","speedControl","normalSpeed","lockedSpeed","bulletCollisionRadius","fishCollisionRadius","collisionPrecision","spatialGrid","cellSize","grid","autoAimThreshold","autoAimStrength","collisionBox","fishWidth","fishHeight","bulletWidth","bulletHeight","hitCompensation","rightSideBonus","spawnBonus","lastSyncTime","syncInterval","syncTimer","bombConfig","explosionRadius","maxDamagePercent","minDamagePercent","hitEffectConfig","flashDuration","flashScale","flashOpacity","flashRadius","flashIntensity","glowIntensity","flashCount","flashInterval","maxEffects","effectPool","objectPools","pool","active","maxSize","create","id","x","y","angle","speed","damage","type","hitCount","rapidFireMultiplier","lastUpdate","reset","obj","fish","scale","rotation","originalSpeed","isCaught","isSelected","currentHp","originalHp","reward","isVisible","explosionCanvas","explosionCtx","explosionParticles","canvasReady","canvasWidth","canvasHeight","bulletWarningShow","hpWarningShow","currentWarningFish","currentHour","onLoad","num","size","onShow","site_title","wx_group","app_logo","pop_con","is_epay","home_bg","normalSpeeds","laserSpeeds","shotgunSpeeds","Object","popContent","onHide","clearTimeout","clearInterval","console","onReady","setTimeout","onUnload","computed","isMorning","methods","startGameLoop","cancelAnimationFrame","stopGameLoop","updateAll","updateBullets","bullet","updateFish","updateEffects","effect","initFish","calculateReward","selectFish","checkAndFire","uni","title","icon","duration","fire","time","now","bulletCost","count","updatedAt","createNormalBullet","startX","startY","createLaserBullet","pierceCount","createShotgunBullets","calculateDamage","baseDamage","checkCollision","fishCenterX","bulletX","endX","pointToLineDistance","param","xx","yy","handleBulletHit","baseDamagePercent","damageMultiplier","damageEffectFn","getEffectFromPool","opacity","particles","lifeTime","resetEffect","addHitEffect","particle","addExplosionEffect","deltaTime","requestAnimationFrame","catchEffect","centerX","distance","shockwave","fishInCell","soundName","sound","poolType","vx","vy","color","alpha","life","p","flag","cachedHp","hp","url"],"mappings":";;;;;;;;;;;;;AAAA;AAGA;AACA;AAHA;AACAA,EAAE,CAACC,iCAAiC,GAAGC,mBAAmB;AAG1DC,UAAU,CAACC,aAAI,CAAC,C;;;;;;;;;;;;;ACLhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6H;AAC7H;AACwD;AACL;AACsC;;;AAGzF;AACgL;AAChL,gBAAgB,yLAAU;AAC1B,EAAE,0EAAM;AACR,EAAE,2FAAM;AACR,EAAE,oGAAe;AACjB;AACA;AACA;AACA;AACA;AACA,EAAE,+FAAU;AACZ;AACA;;AAEA;AACe,gF;;;;;;;;;;;;ACvBf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,aAAa,oMAEN;AACP,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAqpB,CAAgB,0qBAAG,EAAC,C;;;;;;;;;;;;;;;;;;;;;;;AC0LzqB;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAjBA;AACA;AACA;AACA;;AAEA;AACA;EACAC;EACAC;EACAC;EACAC;EAAA;EACAC;AACA;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA;EAAA;IAAA;EAAA,CAAC;AAAD;AAAA,eAmBA;EACAC;EACAC;IACAC;IACAC;IACAC;IACAC;IACAC;IACAC;IACAC;IACAC;IACAC;IACAC;IACAC;EACA;EACAC;EACAC;IACA;MACA;MACAC;QACAC;MACA;MACAC;MAAA;MACAC;MACA;MACAC;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;MACA;;MACAC;MAAA;MACA;MACAC;MACAC;MACAC;MACAC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;MACA;MACA;MACAC;QACAlB;QACAmB;MACA;MACA;MACAC;MAAA;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MACAC;MAEA;MACAhC;MACAiC;MACAC;MACAC;MAAA;MACAC;MAAA;MACAC;MAAA;;MAEA;MACAC;MACAC;MAAA;MACAC;MACAC;MAAA;MACAC;MAEA;MACAC;QACAC;QAAA;QACAhE;QAAA;QACAiE;MACA;;MACAC;QACAF;QAAA;QACAhE;QAAA;QACAiE;MACA;;MAEA;MACAE;MAAA;MACAC;MAAA;MACAC;MAAA;MACAC;MAAA;MACAC;MAAA;MACAC;MAAA;MACAC;MAAA;;MAEA;MACAC;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;MACA;;MAEA;MACAC;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;MACA;;MACA;MACAC;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;MACA;;MACA;MACAC;MAAA;MACAC;MAAA;MACAC;MAAA;;MAEA;MACAC;QACAC;QAAA;QACAC;QAAA;QACAC;MACA;;MAEA;MACAC;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;QAAA;QACAC;MACA;;MAEA;MACAC;QACAjF;UACAkF;UACAC;UACAC;UAAA;UACAC;YAAA;cACAC;cACAC;cACAC;cACAC;cACAC;cACAC;cACAC;cACAzF;cACAC;cACAyF;cACAC;cACAnD;cACAoD;YACA;UAAA;UACAC;YACAC;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACA;UACA;QACA;QACAC;UACAhB;UACAC;UACAC;UAAA;UACAC;YAAA;cACAC;cACAC;cACAC;cACAW;cACAC;cACAV;cACAW;cACAC;cACAC;cACAC;cACAC;cACAC;cACAvG;cACAC;cACAwF;cACAe;YACA;UAAA;UACAX;YACAC;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACAA;YACA;UACA;QACA;MACA;MACA;MACAW;MACAC;MACAC;MACAC;MACAC;MACAC;MACA;MACAC;MACAC;MACAC;MACA;MACAC;IACA;EACA;EACAC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IAEA;IACA;MAAAC;MAAAC;IAAA;IACA;IACA;EACA;EACAC;IAAA;IAuBA;IACA;;IAEA;IACA;;IAEA;IACA;;IAEA;IACA;MACA;QAAAC;QAAAC;QAAAC;QAAAC;QAAAC;QAAAC;QAAAC;QAAAC;QAAAC;QAAAxI;QAAAE;MACA;MACAuI;QACAT;QACAC;QACAC;QACAQ;QACAN;QACAC;MACA;MACA;MACA;MACA;MACA;MACA;IACA;EACA;EACAM;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;MACAC;MACA;IACA;IACA;IACA;MACA;IACA;IACA;IACA;IACA;IACAA;IACAC;IACA;IACA;IACA;IACAC;EACA;EACAC;IAAA;IACA;IACAC;MACA;IACA;EACA;EACAC;IACA;IACA;IACA;IACA;EAAA,CACA;EACAC;IACAC;MACA;MACA;IACA;EACA;EACAC;IACA;IACA;IACA;IACAC;MAAA;MACA;QACAC;MACA;MAEA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;MACA;MAEA;IACA;IAEA;IACAC;MACA;QACAD;QACA;MACA;IACA;IACA;IACAE;MACA;MACA;;MAEA;MACA;;MAEA;MACA;;MAEA;MACA;IACA;IAEA;IACAC;MACA;MACA;QACA;QAEA;UACA;UACAC;QACA;QAEA;QAEA;QACA;QACAA;QACAA;QAEA,IACAA,4BACAA,iDACAA,6BACAA,iDACA;UACA;UACA;UACA;QACA;QAEA;UACA;UACA;YACA;YACA;UACA;QACA;MACA;IACA;IAEA;IACAC;MACA;MACA;MACA;MAEA;QACA;;QAEA;QACA;QACAnD;;QAEA;QACA;UACAA;UACAA;UACA;UACAA;UACAA;UACAA;QACA;MACA;IACA;IACA;IACAoD;MACA;QACA;QACAC;QAEA;UACA;UACA;QACA;MACA;IACA;IACA;IACA;IACAC;MAAA;MACA;MACA;QAAA;MAAA;;MAEA;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA;;MAEA;QACA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;QAEA;QACArB,uDACAjC;UACAX;UACAC;UACAW;UACAC;UACAV;UACAW;UACAC;UACAC;UACAC;UACAC;UACAC;UACAvG;UACAC;UACAwF;UACAe;QAAA,GACA;QACA;MACA;IACA;IACA8C;MACA;MACA;MACA;MACA;IACA;IACA;IACAC;MACA;QACA;QACA;MACA;MACA;;MAEA;MACA;QACA;QACA;QACA;MACA;;MAEA;MACA;MACA;MACAxD;;MAEA;MACA;QACAA;MACA;MACAA;;MAEA;MACA;MACA;;MAEA;MACA;MACA;;MAEA;MACA;MACA;MACA;;MAEA;MACAT;;MAEA;MACA;;MAEA;MACA;IACA;IACA;IACA;IACAkE;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,MAEA;kBAAA;kBAAA;gBAAA;gBACA;gBAAA,iCACA;cAAA;gBAAA,MAGA;kBAAA;kBAAA;gBAAA;gBACAC;kBACAC;kBACAC;kBACAC;gBACA;gBAAA,iCACA;cAAA;gBAAA,MAGA;kBAAA;kBAAA;gBAAA;gBACAH;kBACAC;kBACAC;kBACAC;gBACA;gBAAA,iCACA;cAAA;gBAAA,iCAEA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IACA;IACA;IACAC;MAAA;MAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBACAC;gBAAA,MACAA;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBAGA;;gBAEA;gBAAA;gBAAA,OACA;cAAA;gBAAA;kBAAA;kBAAA;gBAAA;gBAAA;cAAA;gBAAA,MAEA;kBAAA;kBAAA;gBAAA;gBACAL;kBACAC;kBACAC;kBACAC;gBACA;gBAAA;cAAA;gBAIA;gBACAG;gBACApE;gBACA;kBACAA;gBACA;gBACA;;gBAEA;gBACAqE;gBACA;kBACAA;gBACA;kBACAA;gBACA;;gBAEA;gBAAA,MACA;kBAAA;kBAAA;gBAAA;gBACAP;kBACAC;kBACAC;kBACAC;gBACA;gBAAA;cAAA;gBAIA;gBACA;gBACA;gBACAH;kBACAQ;kBACAC;gBACA;;gBAEA;gBACA;;gBAEA;gBACA;kBACA;gBACA;kBACA;gBACA;kBACA;gBACA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA;IACA;IACAC;MAAA;MACA;QAAA;MAAA;MACA;MAEA;MACAnC;QACA5C;QACAC;QACAC;QACAC;QACAC;QACAC;QACAzF;QACAC;QACAyF;QACAC;QACAnD;QACA4H;QACAC;MACA;MACA;MACA;IACA;IACAC;MAAA;MAAA;MACA;QAAA;MAAA;MACA;MAEA;MACA;MACA;MACA;;MAEAtC;QACA5C;QACAC;QACAC;QACAC;QACAC;QACAC;QACAzF;QAAA;QACAC;QACAsK;QACA7E;QACAC;QACAnD;QACAoD;MACA;MACA;MAEA2C;QACA;MACA;IACA;IACAiC;MAAA;MAAA;MACA;QACAjC;UACA;UACAP;YACA5C;YACAC;YACAC;YACAC;YACAC;YACAC;YACAzF;YACAC;YACAyF;YACAC;YACAnD;UACA;UACA;QACA;MACA;MACA;IACA;IACA;IACAiI;MACA;MACA;;MAEA;MACA;QACA;UAAA;UACAC;UACA;QACA;UAAA;UACAA;UACA;QACA;UAAA;UACAA;UACA;MAAA;;MAGA;MACA,mDACA;;MAEA;MACA;MAEA;IACA;IACA;IACA;IACAC;MACA;MACA;QACA;MACA;MACA;MAEA;MACA;;MAEA;MACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACA;;QAEA;QACA;UACA;UACA;UACA;;UAEA;UACA,wCACAC,0BACAC,kBACAC,WACA;;UAEA;UACA;YACA;UACA;QACA;;QAEA;QACA;UACA;UACA;UAEA;UACA;;UAEA;UACA,yCACAF,4BACAC,kBACAC,WACA;;UAEA;UACA;YACA;UACA;QACA;MACA;QACA;QACA;UACA;UACA;UACA;UAEA;UACA;UACA;UAEA;YACA;UACA;QACA;QAEA;UACA;UACA;UAEA;UACA;UAEA;UACA;UACA;UAEA;YACA;UACA;QACA;MACA;MACA;IACA;IAEA;IACAC;MACA;MACA;MACA;MACA;MAEA;MACA;MACA;MAEA;QACAC;MACA;MAEA;MAEA;QACAC;QACAC;MACA;QACAD;QACAC;MACA;QACAD;QACAC;MACA;MAEA;MACA;MAEA;IACA;IAEA;IACAC;MAAA;MACA;MACA;MACA;QACA;MACA;QACA;MACA;MACA;;MAEA;MACA;QACA;QACA;UACA;YACA/C;YACArC;YACA;UACA;UACAA;UACAwC;YACAxC;UACA;UACArB;QACA;MACA;;MAEA;MACA;MAEA;MACA;MACA;MACA;;MAEA;MACA;QACA0G;QACAC;MACA;QACA;QACA;UACAtF;QACA;QACAA;;QAEA;QACA;UACA;YACA;cACA;cACA;cAEA;gBACA;gBACA;gBACA;kBACA;kBACAqF;gBACA;kBACA;kBACA;kBACA;oBACA;oBACA;oBACA;oBACAA;kBACA;oBACA;oBACA;oBACA;oBACAA;kBACA;kBACA;kBACAC,oCACA;kBAAA;kBACA;gBACA;cACA;gBACA;gBACAD;gBACAA;cACA;YACA;cACA;cACA;gBACAA;cACA;gBACA;gBACA;kBACA;kBACA;kBACAA;gBACA;kBACA;kBACA;kBACAA;gBACA;gBACAC,oCACA,sBACA;cACA;YACA;YACAC;cAAA;YAAA;YACA;UACA;YACA;cACA;cACA;cAEA;gBACA;gBACA;kBACAF;gBACA;kBACA;oBACA;oBACA;oBACA;oBACAA;kBACA;oBACA;oBACA;oBACAA;kBACA;kBACAC,oCACA,wBACA;gBACA;cACA;gBACA;gBACAD;gBACAA;cACA;YACA;cACA;cACA;gBACAA;cACA;gBACA;kBACA;kBACA;kBACAA;gBACA;kBACA;kBACA;kBACAA;gBACA;gBACAC,oCACA,wBACA;cACA;YACA;YACAC;cAAA;YAAA;YACA;UACA;YACA;cACA;cACA;cAEA;gBACA;gBACA;kBACAF;gBACA;kBACA;oBACA;oBACA;oBACA;oBACAA;kBACA;oBACA;oBACA;oBACAA;kBACA;kBACAC,oCACA,sBACA;gBACA;cACA;gBACA;gBACAD;gBACAA;cACA;YACA;cACA;cACA;gBACAA;cACA;gBACA;kBACA;kBACA;kBACAA;gBACA;kBACA;kBACA;kBACAA;gBACA;gBACAC,oCACA,sBACA;cACA;YACA;YACAC;cAAA;YAAA;YACA;UACA;YACA;YACA;cACA;cACA;cACA;;cAEA;cACA;gBACA;gBACA;gBACA;kBACA;kBACAF;gBACA;kBACA;kBACA;kBACA;kBACAA;kBACAC;gBACA;cACA;gBACA;gBACA;gBACAD;gBACAA;cACA;YACA;cACA;cACA;cACA;gBACAA;cACA;gBACA;gBACA;gBACAA;gBACAC;cACA;YACA;YACAC;cAAA;YAAA;YACA;UACA;YACA;YACA;cACA;cACA;cACA;;cAEA;cACA;gBACA;gBACA;gBACA;kBACA;kBACAF;gBACA;kBACA;kBACA;kBACA;kBACAA;kBACAC;gBACA;cACA;gBACA;gBACA;gBACAD;gBACAA;cACA;YACA;cACA;cACA;cACA;gBACAA;cACA;gBACA;gBACA;gBACAA;gBACAC;cACA;YACA;YACAC;cAAA;YAAA;YACA;QAAA;MAEA;;MAEA;MACA;;MAEA;MACA;MAEA;;MAEA;MACAvF;;MAEA;MACA;MACA;QACA;QACA;MACA;;MAEA;MACA;;MAEA;MACA;QACAA;;QAEA;QACA;UACA;UACA;QACA;QAEA;MACA;;MAEA;MACAkD;;MAEA;MACA;QACA;UACA;QACA;MACA;QACA;MACA;;MACA;IACA;IAEA;IACA;IACAsC;MACA;QAAA;MAAA;MACA;QACAnC;UACAjE;UACAC;UACAC;UACAW;UACAwF;UACAC;UACAzG;UACA0G;QACA;QACA;MACA;MACA;IACA;IAEA;IACAC;MACAvC;MACAA;MACAA;MACAA;MACAA;MACAA;MACAA;MACA;IACA;IAEA;IACAwC;MAAA;MACA;MACA;QAAA;MAAA;MACA;QACA;MACA;;MAEA;MACAxC;MACAA;MACAA;MACAA;;MAEA;MACA;QACA;QACA;UACAjE;UACAC;UACAC;UACAC;UACAU;UACAwF;QACA;QACApC;MACA;;MAEA;MACA;;MAEA;MACAb;QACAa;QACAA;QACAA;UACAyC;UACAA;QACA;MACA;;MAEA;MACAtD;QACA;UAAA;QAAA;QACA;UACA;UACA;QACA;MACA;IACA;IAEA;IACAuD;MAAA;MAAA;MACA;MACA;QAAA;MAAA;MACA;QACA;MACA;;MAEA;MACA1C;MACAA;MACAA;MACAA;;MAEA;MACA;MACA;QACA;QACA;UACAjE;UACAC;UACAC;UACAC;UACAU;UACAwF;QACA;QACApC;MACA;;MAEA;MACA;;MAEA;MACAb;QACAa;QACAA;QACAA;UACAyC;UACAA;QACA;MACA;;MAEA;MACAtD;QACA;UAAA;QAAA;QACA;UACA;UACA;QACA;MACA;IACA;EAAA,mFAGAwD;IACA;MACA;MACA3C;MAEA;QACA;QACA;MACA;IACA;EACA,8FAGArD;IAAA;IACA;IACA;MACAZ;MACAC;MACAC;MACAW;MACAwF;IACA;IAEA;;IAEA;IACAQ;MACAC;MACAA;IACA;;IAEA;IACA1D;MACA;QAAA;MAAA;MACA;QACA;MACA;IACA;EACA,gGAGAxC;IACA;IACA;;IAEA;IACA;;IAEA;IACA0D;;IAEA;IACA;;IAEA;IACA1D;IACAA;IACAA;IACAA;IACAA;IACAA;EACA,sFAEAmG;IAAA;IACA;MAAAlI;MAAAC;MAAAC;IAEA;MACA;;MAEA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA6B;;QAEA;QACA;;QAEA;QACA;UACAA;UACA;QACA;MACA;IACA;EACA,sGAEAX;IAAA;IACA;IACA;MACAD;MACAC;MACAC;MACAW;MACAwF;MACAC;MACAhG;IACA;;IAEA;IACA;;IAEA;IACA;IACA;MACA;MACA;QACAN;QACAC;QACAC;QACAC;QACAU;QACAwF;QACAW;MACA;MACA/C;IACA;;IAEA;IACA;IACA;IAEA;MACA;MACA;;MAEA;MACAA;MACAA;;MAEA;MACAA;QACAyC;QACAA;QACAA;MACA;;MAEA;MACA;MAEA;QACAG;MACA;QACA;QACA;UAAA;QAAA;QACA;UACA;QACA;MACA;IACA;IACAA;EACA,wFAEA5G;IAAA;IACA;MACAD;MACAC;MACAC;MACAW;MACAwF;IACA;IAEA;;IAEA;IACA;IACA;IAEA;MACA;MACA;;MAEA;MACAY;MACAA;;MAEA;MACA;MAEA;QACAJ;MACA;QACA;QACA;UAAA;QAAA;QACA;UACA;QACA;MACA;IACA;IACAA;EACA,0GAEA5G;IAAA;IACA;IACA;IAEA;MACA;MACA;MACA;MACA;QACAD;QACAC;QACAC;QACAgC;QACA/B;QACAC;QACAiG;QACAxF;MACA;MACAyF;MACA;IACA;;IAEA;IACA;IACA;IAEA;MACA;MACA;MAEAA;QACA;QACA;QACAI;QACAA;;QAEA;QACAA;QACAA;MACA;;MAEA;MACA;MAEA;QACAG;MACA;QACA;QACAP;UACA;YAAA;UAAA;UACA;YACA;UACA;QACA;MACA;IACA;IAEAO;EACA,0FAGA;IACA;IACA;EACA,8FAEA;IAAA;IACA;IACA;;IAEA;IACA;MACA;MAEA;MACA;MACA;MAEA;QACA;MACA;MACA;IACA;EACA,oFAEA/C;IACA;IACA;IACA;;IAEA;IACA;MACA;QACA;QACA;QACAoD;UAAA;QAAA;MACA;IACA;IAEA;EACA,oFAEApD;IACA;IAEA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;MACA;MACA;;MAEA;MACA;MACA;MACAA;IACA;EACA,gFAGA;IACA;IACA;MACAnL;MACAC;MACAC;MACAC;MACAC;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;EACA,4EAEAoO;IACA;;IAEA;IACA;IACA;EACA,sFAEA;IACAtE;MACA;QACAuE;MACA;IACA;EACA,sFAEA;IACAvE;MACA;QACAuE;MACA;IACA;IACA;IACA;EACA,gFAGAC;IACA;IACA;IAEA;MACA1G;IACA;MACAA;IACA;IAEAf;IACA;EACA,kFAGAyH;IACA;IACA;MACAzH;MACA;QACAA;MACA;IACA;EACA,4EAGAyH;IACA;IACAzH;IACAA;EACA,kGAGA;IACA;IAEA;MACA;MACA;MACA;MACA;;MAEA;MACA;MACA;;MAEA;IACA;MACA;IAAA;EAEA,oGAGAK;IAAA;MAAA;IACA;MACA;MACAmD;QACA;MACA;MACA;IACA;IAEA;IACA;IAEA;MACA;MACA;MACA;MACA;MAEAkD;QACArG;QACAC;QACAoH;QACAC;QACArF;QACAsF;QACAC;QACAC;MACA;IACA;IAEA;IACA;EACA,4FAGA;IAAA;IACA;IAEA;MACA;MACA;;MAEA;MACA;QACA;QAEAC;QACAA;QACAA;QACAA;QACAA;;QAEA;QACA;QACA;;QAEA;QACA;QACA;QACA;QAEA;UACA;QACA;MACA;;MAEA;MACA;;MAEA;MACA;QACAd;UAAA;QAAA;MACA;IACA;MACA;MACA;IACA;EACA,0GAGA;IACA,cACA;IAAA;IACA;IAAA;IACA;IAAA;IACA;IAAA,CACA;;IACA;EACA,sEAEA;IAAA;MAAA;IAAA;MAAA;MAAA;QAAA;UAAA;YAAA;cAAAe;cACA;cACA;;cAEA;cACA;;cAEA;cACA;cACA;cACA;;cAEA;cACA;cACA;cACA;cACA;;cAEA;cACA;gBAAA3F;gBAAAC;cAAA;cAEA;cAEA;gBACAoC;kBACAC;kBACAC;gBACA;cACA;;cAEA;cACA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA;EACA,sFAGA;IAAA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACApB;MACA;QACA;UACA;;UAEA;UACA;YACA;YACA;YAEA;cACA;cACA;gBACA;gBACA;kBACAxC;kBACAA;gBACA;cACA;YACA;UACA;;UAEA;UACA;QACA;MACA;IACA;EAEA,oFAGAA;IACA;IAEA;IACA;IAEAiH;MACAC;MACA/C;IACA;IAEAT;EACA,oFAGA;IACA;IAEA;IACAA;;IAEA;IACA;MACA1D;IACA;EACA,sFAGA;IAAA;IACA;IACA;MACA;MACA0D;QACAyD;MACA;MACA;IACA;IAEA;MACA;MACA;IACA;EACA,oFAGAnH;IACA;IACA;;IAGA;IACA;EACA,wFAGA;IACA;IACA;EACA,4FAGA;IACA;MACA;MACA;QACA;QACA;QACA;MACA;;MAEA;MACA;MACA;IACA;IACA;EACA,8FAGA;IACA;IACA;IACA;EACA,8FAGAM;IACA;IACA;MACA;IACA;IACA;EACA;AAGA;AAAA,2B;;;;;;;;;;;;;AC9uEA;AAAA;AAAA;AAAA;AAAowC,CAAgB,iuCAAG,EAAC,C;;;;;;;;;;;ACAxxC;AACA,OAAO,KAAU,EAAE,kBAKd","file":"pages/tabBar/home.js","sourcesContent":["import 'uni-pages';\n// @ts-ignore\nwx.__webpack_require_UNI_MP_PLUGIN__ = __webpack_require__;\nimport Vue from 'vue'\nimport Page from './pages/tabBar/home.vue'\ncreatePage(Page)","import { render, staticRenderFns, recyclableRender, components } from \"./home.vue?vue&type=template&id=28aa9427&scoped=true&\"\nvar renderjs\nimport script from \"./home.vue?vue&type=script&lang=js&\"\nexport * from \"./home.vue?vue&type=script&lang=js&\"\nimport style0 from \"./home.vue?vue&type=style&index=0&id=28aa9427&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\runtime\\\\componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"28aa9427\",\n  null,\n  false,\n  components,\n  renderjs\n)\n\ncomponent.options.__file = \"pages/tabBar/home.vue\"\nexport default component.exports","export * from \"-!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\loaders\\\\templateLoader.js??vue-loader-options!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--17-0!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\template.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-uni-app-loader\\\\page-meta.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\index.js??vue-loader-options!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\style.js!./home.vue?vue&type=template&id=28aa9427&scoped=true&\"","var components\ntry {\n  components = {\n    loginPopup: function () {\n      return import(\n        /* webpackChunkName: \"components/loginPopup/loginPopup\" */ \"@/components/loginPopup/loginPopup.vue\"\n      )\n    },\n  }\n} catch (e) {\n  if (\n    e.message.indexOf(\"Cannot find module\") !== -1 &&\n    e.message.indexOf(\".vue\") !== -1\n  ) {\n    console.error(e.message)\n    console.error(\"1. 排查组件名称拼写是否正确\")\n    console.error(\n      \"2. 排查组件是否符合 easycom 规范，文档：https://uniapp.dcloud.net.cn/collocation/pages?id=easycom\"\n    )\n    console.error(\n      \"3. 若组件不符合 easycom 规范，需手动引入，并在 components 中注册该组件\"\n    )\n  } else {\n    throw e\n  }\n}\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  var l0 = _vm.__map(_vm.fishList, function (fish, index) {\n    var $orig = _vm.__get_orig(fish)\n    var m0 = _vm.formatHpPercentage(fish.currentHp, fish.originalHp)\n    return {\n      $orig: $orig,\n      m0: m0,\n    }\n  })\n  if (!_vm._isMounted) {\n    _vm.e0 = function ($event) {\n      _vm.bulletRechargeShow = true\n    }\n  }\n  _vm.$mp.data = Object.assign(\n    {},\n    {\n      $root: {\n        l0: l0,\n      },\n    }\n  )\n}\nvar recyclableRender = false\nvar staticRenderFns = []\nrender._withStripped = true\n\nexport { render, staticRenderFns, recyclableRender, components }","import mod from \"-!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\babel-loader\\\\lib\\\\index.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--13-1!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\script.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\index.js??vue-loader-options!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\style.js!./home.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\babel-loader\\\\lib\\\\index.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--13-1!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\script.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\index.js??vue-loader-options!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\style.js!./home.vue?vue&type=script&lang=js&\"","<!--\n  作者: xcooo\n  创建日期: 2025-05-20\n  描述: 本页面展示泡泡机游戏，包含火焰爆炸光圈等视觉效果，击中特效，二次开发请联系资深全栈开发QQ：602006050, 当前代码已全部分区注释，方便阅读。\n-->\n<template>\n  <view class=\"home-page\" :style=\"{ backgroundImage: `url(${home_bg})` }\">\n    <!-- 根据时间动态渲染组件 -->\n    <!-- <CloudBackgroundLight v-if=\"isMorning\" />\n    <CloudBackgroundBlack v-else /> -->\n    <!-- 顶部按钮 -->\n    <view class=\"top-bar\">\n      <view class=\"top-left-bar\">\n        <image class=\"fresh-img\"\n          src=\"https://img.alicdn.com/imgextra/i3/2200676927379/O1CN01w3oTPS24Ndcu3kzjv_!!2200676927379.png\"\n          mode=\"widthFix\" lazy-load=\"false\" binderror=\"\" bindload=\"\" @click=\"fresh(1)\" />\n        <image class=\"my-img\"\n          src=\"https://img.alicdn.com/imgextra/i2/2200676927379/O1CN01yTDenk24NdcuaaT3V_!!2200676927379.png\"\n          mode=\"widthFix\" lazy-load=\"false\" binderror=\"\" bindload=\"\" @click=\"goMy\" />\n      </view>\n      <view class=\"top-right-bar\">\n        <image class=\"power-img\"\n          src=\"https://img.alicdn.com/imgextra/i2/2200676927379/O1CN01K8Cvnc24NdctupLmt_!!2200676927379.png\"\n          mode=\"widthFix\" lazy-load=\"false\" binderror=\"\" bindload=\"\" @click=\"showPowerReference\" />\n        <image class=\"feedback-img\"\n          src=\"https://img.alicdn.com/imgextra/i1/2200676927379/O1CN011XZwN524Ndcsva0Pc_!!2200676927379.png\"\n          mode=\"widthFix\" lazy-load=\"false\" binderror=\"\" bindload=\"\" @click=\"showFeedback\" />\n      </view>\n    </view>\n\n    <!-- 游戏区域 -->\n    <view class=\"game-area\">\n      <!-- 左侧功能按钮 -->\n      <view class=\"left-controls\">\n        <view class=\"control-item\" @click=\"switchWeapon\">\n          <image src=\"https://img.alicdn.com/imgextra/i3/2200676927379/O1CN01PTdLmK24NdcuTY5IJ_!!2200676927379.png\"\n            mode=\"widthFix\" class=\"control-icon\"></image>\n          <text>切换武器</text>\n        </view>\n        <view class=\"control-item\" @click=\"showMyPrizes\">\n          <image src=\"https://img.alicdn.com/imgextra/i3/2200676927379/O1CN01Ex2HTc24NdcusFQOY_!!2200676927379.png\"\n            mode=\"widthFix\" class=\"control-icon\"></image>\n          <text>我的奖品</text>\n        </view>\n      </view>\n\n      <!-- 右侧功能按钮 -->\n      <view class=\"right-controls\">\n        <view class=\"control-item\" @click=\"reloadAmmo\">\n          <image src=\"https://img.alicdn.com/imgextra/i2/2200676927379/O1CN01bRt6rX24NdcvxXmDy_!!2200676927379.png\"\n            mode=\"widthFix\" class=\"control-icon\"></image>\n          <text>补充弹药</text>\n        </view>\n        <view class=\"control-item\" @click=\"showRechargeRules\">\n          <image src=\"https://img.alicdn.com/imgextra/i1/2200676927379/O1CN013coOsN24Ndcu7e13U_!!2200676927379.png\"\n            mode=\"widthFix\" class=\"control-icon\"></image>\n          <text>充值须知</text>\n        </view>\n      </view>\n\n      <!-- 鱼群 -->\n      <view v-for=\"(fish, index) in fishList\" :key=\"`fish-${fish.id}-${index}`\" class=\"fish-container\" :class=\"{\n        'fish-caught': fish.isCaught,\n        'fish-selected': fish.isSelected,\n        'fish-hit': fish.isHit\n      }\" :style=\"{\n  left: fish.x + 'px',\n  top: fish.y + 'px',\n  transform: `scale(${fish.scale})`,\n  transition: fish.isCaught ? 'all 0.5s' : 'none',\n  display: fish.isVisible === false ? 'none' : 'block'\n}\" @click=\"selectFish(fish)\">\n        <!-- 泡泡背景 -->\n        <view class=\"bubble-bg\">\n          <image src=\"https://img.alicdn.com/imgextra/i1/2200676927379/O1CN01rBCGZY24NdcqOdxiS_!!2200676927379.png\"\n            mode=\"aspectFit\" class=\"bubble-img\" />\n        </view>\n        <!-- 奖品图片 -->\n        <view class=\"fish-content\">\n          <image :src=\"fish.thumb\" mode=\"aspectFit\" class=\"fish-img\" />\n        </view>\n        <!-- 血条 -->\n        <view class=\"hp-bar\">\n          <view class=\"hp-bar-bg\">\n            <text class=\"hp-text\">{{ formatHpPercentage(fish.currentHp, fish.originalHp) }}%</text>\n          </view>\n          <view class=\"hp-bar-inner\" :style=\"{ width: `${(fish.currentHp / fish.originalHp) * 100}%` }\"></view>\n        </view>\n        <!-- 击中特效 -->\n        <view v-if=\"fish.isHit\" class=\"hit-effect\" :style=\"{\n          '--flash-duration': hitEffectConfig.flashDuration + 'ms',\n          '--flash-scale': hitEffectConfig.flashScale,\n          '--flash-opacity': hitEffectConfig.flashOpacity,\n          '--flash-radius': hitEffectConfig.flashRadius + 'rpx',\n          '--flash-intensity': hitEffectConfig.flashIntensity,\n          '--glow-intensity': hitEffectConfig.glowIntensity\n        }\"></view>\n      </view>\n\n      <!-- 子弹 -->\n      <view v-for=\"(bullet, index) in bullets\" :key=\"`bullet-${bullet.id || index}`\" class=\"bullet\" :class=\"[bullet.type]\"\n        :style=\"{\n          left: `${bullet.x}px`,\n          top: `${bullet.y}px`,\n          transform: `rotate(${bullet.angle}deg)`\n\n        }\">\n        <template v-if=\"bullet.type === 'laser'\">\n          <view class=\"laser-core\"></view>\n          <view class=\"laser-glow\"></view>\n          <view class=\"laser-flame\"></view>\n        </template>\n      </view>\n\n      <!-- 炮台 -->\n      <view class=\"cannon-area\">\n        <view class=\"cannon-controls\">\n          <!-- <button class=\"control-btn\" @click=\"rotateLeft\">←</button> -->\n          <view class=\"fire-btn\" :style=\"{ transform: `rotate(${cannonAngle}deg)` }\">\n            <image :src=\"currentWeaponText\" mode=\"aspectFit\" class=\"cannon-img\" />\n          </view>\n          <!-- <button class=\"control-btn\" @click=\"rotateRight\">→</button> -->\n        </view>\n        <view class=\"bullet-count\">{{ localCoin }}/子弹</view>\n      </view>\n\n      <!-- 伤害数字显示 -->\n      <view v-for=\"(effect, index) in hitEffects\" :key=\"`effect-${effect.id}-${index}`\" class=\"explosion-container\"\n        :style=\"{\n          left: effect.x + 'px',\n          top: effect.y + 'px',\n          transform: `scale(${effect.scale})`,\n          opacity: effect.opacity\n        }\">\n        <view class=\"explosion-effect\"></view>\n        <view v-for=\"(particle, pIndex) in effect.particles\" :key=\"`particle-${effect.id}-${pIndex}`\" class=\"particle\"\n          :style=\"{\n            transform: `rotate(${particle.angle}deg) scale(${particle.scale})`,\n            opacity: particle.opacity\n          }\">\n        </view>\n      </view>\n    </view>\n\n    <!-- 弹药充值弹窗 -->\n    <bullet-recharge-dialog :show.sync=\"bulletRechargeShow\" :localCoin=\"localCoin\" :coin-list=\"coinList\"\n      @confirm=\"confirmRecharge\" />\n    <!-- 武器切换弹窗 -->\n    <weapon-switch-dialog :show.sync=\"weaponSwitchShow\" :weapons=\"weapons\" :current-weapon=\"currentWeapon\"\n      @select=\"selectWeapon\" />\n    <!-- 我的奖品弹窗 -->\n    <my-prizes-dialog :show.sync=\"myPrizesShow\" :prizes=\"myPrizes\" />\n    <!-- 火力值弹窗 -->\n    <PowerReferenceDialog :show.sync=\"powerReferenceShow\" />\n    <!-- 投诉反馈弹窗 -->\n    <FeedbackDialog :show.sync=\"feedbackShow\" />\n    <!-- 充值须知弹窗 -->\n    <RechargeRulesDialog :show.sync=\"rechargeRulesShow\" />\n    <!-- 中奖弹窗 -->\n    <Reward :show.sync=\"rewardPopupVisible\" :reward=\"rewardData\" />\n    <!-- 子弹警告弹窗 -->\n    <BulletWarningDialog :show.sync=\"bulletWarningShow\" @confirm=\"bulletRechargeShow = true\" />\n    <loginPopup :show.sync=\"loginVisible\"></loginPopup>\n    <!--血条警告提示弹窗 -->\n    <HpTopAlert :show.sync=\"hpWarningShow\" />\n    <!-- 炸弹Canvas定义 -->\n    <canvas type=\"2d\" id=\"explosionCanvas\" canvas-id=\"explosionCanvas\" class=\"explosion-canvas\"></canvas>\n  </view>\n</template>\n\n<script>\nconst switchMp3 = 'https://www.img.xcooo.cn/uploads/2024/02/17887756404cea30.mp3'\nconst switchMusic = uni.createInnerAudioContext();\nconst bgMp3 = ''\nconst bgMusic = uni.createInnerAudioContext();\n\n// 音频资源路径\nconst AUDIO_RESOURCES = {\n  shoot: '../../static/sounds/shoot.mp3',\n  laser: '../../static/sounds/laser.mp3',\n  laser_2: '../../static/sounds/laser_2.mp3',\n  boom: '../../static/sounds/boom.mp3', // 添加爆炸音效\n  warning: '../../static/sounds/warning.mp3', // 添加警告音效\n};\n\n\nimport homeMixin from './mixin/homeMixin.js'\n\nimport { mapGetters } from 'vuex'\nimport BulletRechargeDialog from '@/components/dialogs/BulletRechargeDialog.vue'\nimport WeaponSwitchDialog from '@/components/dialogs/WeaponSwitchDialog.vue'\nimport MyPrizesDialog from '@/components/dialogs/MyPrizesDialog.vue'\nimport PowerReferenceDialog from '@/components/dialogs/PowerReferenceDialog.vue'\nimport FeedbackDialog from '@/components/dialogs/FeedbackDialog.vue'\nimport RechargeRulesDialog from '@/components/dialogs/RechargeRulesDialog.vue'\nimport Reward from '@/components/dialogs/Reward.vue'\nimport BulletWarningDialog from '@/components/dialogs/BulletWarningDialog.vue'\nimport HpTopAlert from '@/components/dialogs/HpTopAlert.vue'\nimport CloudBackgroundLight from '@/components/cloudBackground/CloudBackgroundLight.vue'\nimport CloudBackgroundBlack from '@/components/cloudBackground/CloudBackgroundBlack.vue'\n\n\nexport default {\n  name: 'home',\n  components: {\n    BulletRechargeDialog,\n    WeaponSwitchDialog,\n    MyPrizesDialog,\n    PowerReferenceDialog,\n    FeedbackDialog,\n    RechargeRulesDialog,\n    Reward,\n    BulletWarningDialog,\n    HpTopAlert,\n    CloudBackgroundLight,\n    CloudBackgroundBlack\n  },\n  mixins: [homeMixin],\n  data () {\n    return {\n      /* ==================== 用户信息 ==================== */\n      userInfo: {\n        coin: 0\n      },\n      localCoin: 0, // 添加本地子弹数量变量\n      listData: [],\n      /* ==================== 血量系统配置 ==================== */\n      hpConfig: {\n        warningThreshold: 15, // 血量警告阈值（百分比）\n        initialDamageBonus: 0.15, // 前10发子弹的伤害加成（降低为15%）\n        initialShotsCount: 10, // 初始高伤害子弹数量\n        initialDamageTarget: 15, // 前10发子弹的目标血量百分比15\n      },\n      warnedFishIds: new Set(), // 记录已经触发过警告的鱼ID\n      /* ==================== 游戏核心数据 ==================== */\n      fishList: [],\n      bullets: [],\n      cannonAngle: 0,\n      gameArea: {\n        width: 0,\n        height: 0,\n        minX: 0,\n        maxX: 0,\n        minY: 0,\n        maxY: 0\n      },\n      /* ==================== 缓存键名配置 ==================== */\n      storageKeys: {\n        localCoin: '_localCoin',\n        localHp: '_localHp_'\n      },\n      /* ==================== 游戏配置参数 ==================== */\n      maxBullets: 10, // 最多允许存在的子弹数\n      moveInterval: null,\n      lastFrameTime: 0,\n      fps: 60,\n      frameInterval: 1000 / 60,\n      hitEffects: [],\n      consecutiveShots: 0,\n      lastShotTime: 0,\n      consecutiveBonus: 0.1,\n      sounds: {},\n      isAudioLoaded: false,\n      coinList: [],\n\n      /* ==================== 充值相关 ==================== */\n      coin: '',\n      checkTimer: null,\n      cancelTimer: null,\n      pendingBulletCost: 0,     // 待同步的子弹消耗\n      lastConsumeTime: 0,       // 上一次同步时间\n      consumeTimer: null,        // 定时器引用\n\n      /* ==================== 游戏状态控制 ==================== */\n      selectedFish: null,\n      fireCooldown: 300, // 最短发射间隔\n      gameLoopId: null,\n      collisionCheckInterval: 50, // 碰撞检测间隔(ms)\n      lastCollisionCheck: 0,\n\n      /* ==================== 武器系统配置 ==================== */\n      bulletSpeeds: {\n        normal: 28,    // 普通子弹速度\n        laser: 18,     // 激光炮速度\n        shotgun: 16    // 散弹炮速度\n      },\n      bulletDamages: {\n        normal: 1.8,   // 普通子弹伤害系数\n        laser: 2.0,    // 激光炮伤害系数\n        shotgun: 2.0   // 散弹炮单发伤害系数\n      },\n\n      /* ==================== 战斗系统配置 ==================== */\n      consecutiveHitBonus: 0.1, // 连续命中加成\n      lastHitTime: 0,           // 上次命中时间\n      consecutiveHits: 0,       // 连续命中次数\n      rapidFireBonus: 0.15,     // 连发伤害加成\n      lastFireTime: 0,          // 上次发射时间\n      rapidFireWindow: 300,     // 连发时间窗口(ms)\n      targetFish: null,         // 当前目标鱼\n\n      /* ==================== 速度控制系统 ==================== */\n      speedControl: {\n        normalSpeed: 1.0,      // 正常移动速度\n        lockedSpeed: 0.6,      // 锁定目标后的移动速度\n        bulletCollisionRadius: 35,  // 子弹碰撞半径\n        fishCollisionRadius: 40,    // 鱼碰撞半径\n        collisionPrecision: 0.8,    // 碰撞检测精度(0-1)\n      },\n\n      /* ==================== 空间划分系统 ==================== */\n      spatialGrid: {\n        cellSize: 100,         // 网格大小\n        grid: {},              // 网格数据\n        autoAimThreshold: 15,  // 自动瞄准阈值\n        autoAimStrength: 0.3,  // 自动瞄准强度\n      },\n      /* ==================== 碰撞系统配置 ==================== */\n      collisionBox: {\n        fishWidth: 90,        // 增加鱼碰撞盒宽度\n        fishHeight: 80,       // 增加鱼碰撞盒高度\n        bulletWidth: 40,       // 增加子弹碰撞盒宽度\n        bulletHeight: 40,      // 增加子弹碰撞盒高度\n        hitCompensation: 1.2,  // 命中补偿系数\n        rightSideBonus: 2.5,   // 增加右侧命中加成\n        spawnBonus: 2.8,       // 新增：刚出现时的命中加成\n      },\n      /* ==================== 同步系统 ==================== */\n      lastSyncTime: 0,        // 上次同步时间\n      syncInterval: 30000,    // 同步间隔(30秒)\n      syncTimer: null,        // 同步定时器\n\n      /* ==================== 炸弹系统配置 ==================== */\n      bombConfig: {\n        explosionRadius: 300,  // 爆炸范围半径\n        maxDamagePercent: 0.05,  // 最大伤害比例（5%）\n        minDamagePercent: 0.02,  // 最小伤害比例（2%）\n      },\n\n      /* ==================== 特效系统配置 ==================== */\n      hitEffectConfig: {\n        flashDuration: 150,    // 爆闪持续时间(ms)\n        flashScale: 1.3,       // 爆闪缩放比例\n        flashOpacity: 0.9,     // 爆闪透明度\n        flashRadius: 100,      // 爆闪范围(rpx)\n        flashIntensity: 2.0,   // 爆闪强度\n        glowIntensity: 3.0,    // 辉光强度\n        flashCount: 3,         // 连续爆闪次数\n        flashInterval: 100,    // 爆闪间隔时间(ms)\n        maxEffects: 10,        // 最大同时存在的特效数量\n        effectPool: [],        // 特效对象池\n      },\n\n      /* ==================== 对象池系统 ==================== */\n      objectPools: {\n        bullets: {\n          pool: [],\n          active: new Set(),\n          maxSize: 50,  // 最大池大小\n          create: () => ({\n            id: Date.now() + Math.random().toString(36).substr(2, 9),\n            x: 0,\n            y: 0,\n            angle: 0,\n            speed: 0,\n            damage: 0,\n            type: '',\n            width: 0,\n            height: 0,\n            hitCount: 0,\n            rapidFireMultiplier: 1,\n            targetFish: null,\n            lastUpdate: 0\n          }),\n          reset: (obj) => {\n            obj.x = 0;\n            obj.y = 0;\n            obj.angle = 0;\n            obj.speed = 0;\n            obj.damage = 0;\n            obj.type = '';\n            obj.width = 0;\n            obj.height = 0;\n            obj.hitCount = 0;\n            obj.rapidFireMultiplier = 1;\n            obj.targetFish = null;\n            obj.lastUpdate = 0;\n            return obj;\n          }\n        },\n        fish: {\n          pool: [],\n          active: new Set(),\n          maxSize: 30,  // 最大池大小\n          create: () => ({\n            id: Date.now() + Math.random().toString(36).substr(2, 9),\n            x: 0,\n            y: 0,\n            scale: 1,\n            rotation: 0,\n            speed: 0,\n            originalSpeed: 0,\n            isCaught: false,\n            isSelected: false,\n            currentHp: 0,\n            originalHp: 0,\n            reward: 0,\n            width: 0,\n            height: 0,\n            type: 1,\n            isVisible: true\n          }),\n          reset: (obj) => {\n            obj.x = 0;\n            obj.y = 0;\n            obj.scale = 1;\n            obj.rotation = 0;\n            obj.speed = 0;\n            obj.originalSpeed = 0;\n            obj.isCaught = false;\n            obj.isSelected = false;\n            obj.currentHp = 0;\n            obj.originalHp = 0;\n            obj.reward = 0;\n            obj.width = 0;\n            obj.height = 0;\n            obj.type = 1;\n            obj.isVisible = true;\n            return obj;\n          }\n        }\n      },\n      /* ==================== 炸弹canvas配置 ==================== */\n      explosionCanvas: null,\n      explosionCtx: null,\n      explosionParticles: [],\n      canvasReady: false,\n      canvasWidth: 0,\n      canvasHeight: 0,\n      /* ==================== 血量/子弹警告弹窗 ==================== */\n      bulletWarningShow: false,\n      hpWarningShow: false,\n      currentWarningFish: null,\n      /* ==================== 时间 ==================== */\n      currentHour: new Date().getHours()\n    }\n  },\n  onLoad (options) {\n    // switchMusic.src = switchMp3\n    const systemInfo = uni.getSystemInfoSync();\n    // 初始化游戏区域尺寸\n    this.gameArea.width = systemInfo.windowWidth;\n    this.gameArea.height = systemInfo.windowHeight - this.tabBarHeight;\n    this.gameArea.minX = 0;\n    this.gameArea.maxX = this.gameArea.width;\n    this.gameArea.minY = this.gameArea.height * 0.1; // 最小Y坐标（屏幕10%位置）\n    this.gameArea.maxY = this.gameArea.height * 0.4; // 最大Y坐标（屏幕40%位置）\n\n    // 初始化对象池\n    this.clearPool('bullets');\n    this.clearPool('fish');\n\n    this.getRechargeList()\n    this.getList({ num: 1, size: 20 })\n    // 初始化空间划分\n    this.initSpatialGrid();\n  },\n  onShow () {\n    // #ifdef H5\n    this.tabBarHeight = 50; // H5环境下的默认高度\n    // 推广码获取\n    let invite_code = this.getUrlCode().invite_code\n    if (invite_code) {\n      uni.setStorageSync('invite_code', invite_code);\n    }\n    let order_info = uni.getStorageSync('order_info_recharge_coin')\n    if (order_info) {\n      this.checkPayStatus()\n    }\n\n    let host = location.host\n    let protocol = window.location.protocol\n    this.redirect_uri = `${protocol}//${host}`\n\n    const { code } = this.getUrlCode()\n    if (code) {\n      this.getOpenid(code)\n    }\n    // #endif\n\n    // 初始化游戏状态（血条和子弹）\n    this.initGameState()\n\n    // 初始化音效\n    this.initSounds()\n\n    // 启动游戏\n    this.startGameLoop()\n\n    // 系统配置初始化\n    this.$store.dispatch('getAppConfig').then((res) => {\n      const { site_title, wx_group, app_logo, pop_con, is_epay, home_bg, normalSpeeds, laserSpeeds, shotgunSpeeds, warningThreshold, initialShotsCount } = res.data;\n      // 更新配置\n      Object.assign(this, {\n        site_title,\n        wx_group,\n        app_logo,\n        popContent: [pop_con],\n        is_epay,\n        home_bg\n      })\n      this.bulletSpeeds.normal = normalSpeeds\n      this.bulletSpeeds.laser = laserSpeeds\n      this.bulletSpeeds.shotgun = shotgunSpeeds\n      this.hpConfig.warningThreshold = warningThreshold\n      this.hpConfig.initialShotsCount = initialShotsCount\n    })\n  },\n  onHide () {\n    // 停止游戏\n    this.stopGameLoop()\n    // 停止所有音效\n    this.stopAllSounds()\n    // 销毁音频实例\n    this.destroySounds()\n    // 清除同步定时器\n    if (this.syncTimer) {\n      clearTimeout(this.syncTimer)\n      this.syncTimer = null\n    }\n    // 同步最后一次子弹数量\n    if (!this.isPaying) {\n      this.initLocalCoin()\n    }\n    // 确保在页面销毁时清理所有对象池\n    this.clearPool('bullets')\n    this.clearPool('fish')\n    clearTimeout(this.cancelTimer)\n    clearInterval(this.checkTimer)\n    // 取消订单检查\n    this.cancelCheckPayStatus()\n    this.loginVisible = false\n    console.log('页面隐藏事件')\n  },\n  onReady () {\n    // 在页面渲染完成后初始化Canvas\n    setTimeout(() => {\n      this.initExplosionCanvas();\n    }, 100);\n  },\n  onUnload () {\n    // console.log('页面隐藏2')\n    // if (!this.isPaying) {\n    //   this.initLocalCoin()\n    // }\n  },\n  computed: {\n    isMorning () {\n      // 早上8点到下午5点为早晨，显示CloudBackgroundLight，其他时间显示CloudBackgroundBlack\n      return this.currentHour >= 8 && this.currentHour < 17\n    }\n  },\n  methods: {\n    /* ==================== 二次开发优化请联系资深全栈开发QQ:602006050 ==================== */\n    /* ==================== 游戏核心循环方法 ==================== */\n    // 启动游戏主循环\n    startGameLoop () {\n      if (this.gameLoopId) {\n        cancelAnimationFrame(this.gameLoopId);\n      }\n\n      const gameLoop = (timestamp) => {\n        // 计算时间增量\n        const deltaTime = timestamp - this.lastFrameTime;\n        this.lastFrameTime = timestamp;\n\n        // 更新所有游戏对象\n        this.updateAll(deltaTime);\n\n        // 继续下一帧\n        this.gameLoopId = requestAnimationFrame(gameLoop);\n      };\n\n      this.gameLoopId = requestAnimationFrame(gameLoop);\n    },\n\n    // 停止游戏主循环\n    stopGameLoop () {\n      if (this.gameLoopId) {\n        cancelAnimationFrame(this.gameLoopId);\n        this.gameLoopId = null;\n      }\n    },\n    // 统一更新所有游戏对象\n    updateAll (deltaTime) {\n      // 更新空间网格\n      this.updateSpatialGrid();\n\n      // 更新子弹位置\n      this.updateBullets(deltaTime);\n\n      // 更新鱼群位置\n      this.updateFish(deltaTime);\n\n      // 更新特效\n      this.updateEffects(deltaTime);\n    },\n\n    // 更新所有子弹\n    updateBullets (deltaTime) {\n      const now = performance.now();\n      for (let i = this.bullets.length - 1; i >= 0; i--) {\n        const bullet = this.bullets[i];\n\n        if (bullet.type === 'laser') {\n          if (now - bullet.lastUpdate < 16) continue;\n          bullet.lastUpdate = now;\n        }\n\n        this.autoAimBullet(bullet);\n\n        const rad = (bullet.angle * Math.PI) / 180;\n        const moveDistance = bullet.speed * (deltaTime / 16.67);\n        bullet.x += Math.sin(rad) * moveDistance;\n        bullet.y -= Math.cos(rad) * moveDistance;\n\n        if (\n          bullet.x < -bullet.width ||\n          bullet.x > this.gameArea.width + bullet.width ||\n          bullet.y < -bullet.height ||\n          bullet.y > this.gameArea.height + bullet.height\n        ) {\n          this.returnToPool('bullets', bullet);\n          this.bullets.splice(i, 1);\n          continue;\n        }\n\n        if (now - this.lastCollisionCheck >= this.collisionCheckInterval) {\n          this.lastCollisionCheck = now;\n          if (this.checkCollision(bullet)) {\n            this.returnToPool('bullets', bullet);\n            this.bullets.splice(i, 1);\n          }\n        }\n      }\n    },\n\n    // 更新鱼群位置\n    updateFish (deltaTime) {\n      const screenWidth = this.gameArea.width;\n      const minY = this.gameArea.minY;\n      const maxY = this.gameArea.maxY;\n\n      this.fishList.forEach(fish => {\n        if (fish.isCaught) return;\n\n        // 使用 deltaTime 计算移动距离\n        const moveDistance = fish.speed * (deltaTime / 16.67); // 16.67ms 是 60fps 的帧时间\n        fish.x -= moveDistance;\n\n        // 如果鱼游出屏幕左边，重置位置到右边\n        if (fish.x < -200) {\n          fish.x = screenWidth + 100;\n          fish.y = minY + Math.random() * (maxY - minY);\n          // 不再重置血条，保持原有状态\n          fish.isCaught = false;\n          fish.isSelected = false;\n          fish._isCaughtTemp = false;\n        }\n      });\n    },\n    // 更新特效\n    updateEffects (deltaTime) {\n      for (let i = this.hitEffects.length - 1; i >= 0; i--) {\n        const effect = this.hitEffects[i];\n        effect.lifeTime -= deltaTime;\n\n        if (effect.lifeTime <= 0) {\n          this.resetEffect(effect);\n          this.hitEffects.splice(i, 1);\n        }\n      }\n    },\n    /* ==================== 鱼群管理方法 ==================== */\n    // 给鱼初始化位置、大小、速度、奖励等信息\n    initFish () {\n      // 随机打乱奖品顺序\n      const shuffledList = [...this.listData].sort(() => Math.random() - 0.5);\n\n      // 计算游戏区域边界\n      const minY = this.gameArea.height * 0.1;\n      const maxY = this.gameArea.height * 0.4;\n      const screenWidth = this.gameArea.width;\n\n      // 计算鱼群分布参数\n      const rowCount = 3;  // 3行\n      const colCount = 4;  // 4列\n      const xSpacing = 200;  // 水平间距\n      const ySpacing = (maxY - minY) / (rowCount + 1);  // 垂直间距\n\n      this.fishList = shuffledList.map((fish, index) => {\n        // 计算行列位置\n        const row = Math.floor(index / colCount);\n        const col = index % colCount;\n\n        // 基础位置计算\n        const baseX = screenWidth + 100 + (col * xSpacing);\n        const baseY = minY + (row + 1) * ySpacing;\n\n        // 添加随机偏移，使分布更自然\n        const randomOffsetX = Math.random() * 50 - 25;  // -25到25的随机偏移\n        const randomOffsetY = Math.random() * 30 - 15;  // -15到15的随机偏移\n\n        // 保存原始速度\n        const originalSpeed = (fish.speed || 1) * 0.5;\n\n        const fishObj = this.getFromPool('fish');\n        Object.assign(fishObj, {\n          ...fish,\n          x: baseX + randomOffsetX,\n          y: baseY + randomOffsetY,\n          scale: 0.5 + Math.random() * 0.2,\n          rotation: 180,\n          speed: originalSpeed,\n          originalSpeed: originalSpeed,\n          isCaught: false,\n          isSelected: false,\n          currentHp: fish.hp,\n          originalHp: fish.hp,\n          reward: this.calculateReward(fish),\n          width: fish.width || 100,\n          height: fish.height || 100,\n          type: fish.type || 1,\n          isVisible: true\n        });\n        return fishObj;\n      });\n    },\n    calculateReward (fish) {\n      // 根据鱼的属性计算奖励\n      const baseReward = fish.blood || 1;\n      const dpsFactor = parseFloat(fish.dps) || 0.05;\n      return Math.floor(baseReward * (1 + dpsFactor * 10));\n    },\n    // 选择鱼并瞄准\n    selectFish (fish) {\n      if (!this.userInfo.id) {\n        this.loginVisible = true\n        return;\n      }\n      if (fish.isCaught) return;\n\n      // 清除上一次选中\n      if (this.selectedFish) {\n        this.selectedFish.isSelected = false;\n        // 恢复原始速度\n        this.selectedFish.speed = this.selectedFish.originalSpeed;\n      }\n\n      // 设置当前鱼为选中\n      this.selectedFish = fish;\n      this.targetFish = fish;\n      fish.isSelected = true;\n\n      // 保存原始速度并降低速度\n      if (!fish.originalSpeed) {\n        fish.originalSpeed = fish.speed;\n      }\n      fish.speed = fish.originalSpeed * this.speedControl.lockedSpeed;\n\n      // 获取鱼中心点坐标\n      const fishCenterX = fish.x + (fish.width || 100) / 2;\n      const fishCenterY = fish.y + (fish.height || 100) / 2;\n\n      // 炮台位置\n      const cannonX = Math.floor(this.gameArea.width / 2);\n      const cannonY = this.gameArea.height - 100;\n\n      // 计算精确角度\n      const dx = fishCenterX - cannonX;\n      const dy = fishCenterY - cannonY;\n      let angle = Math.atan2(dx, -dy) * (180 / Math.PI);\n\n      // 限制角度范围 [-60, 60]\n      angle = Math.max(-60, Math.min(60, angle));\n\n      // 设置炮台角度\n      this.cannonAngle = angle;\n\n      // 自动开火\n      this.fire();\n    },\n    /* ==================== 子弹系统方法 ==================== */\n    // 发射子弹前的检查\n    async checkAndFire () {\n      // 检查子弹数量\n      if (this.localCoin <= 0) {\n        this.bulletRechargeShow = true\n        return false\n      }\n      // 散弹炮特殊检查\n      if (this.currentWeapon === 3 && this.localCoin < 3) {\n        uni.showToast({\n          title: '子弹不足3发',\n          icon: 'none',\n          duration: 1500\n        })\n        return false\n      }\n      // 激光炮特殊检查\n      if (this.currentWeapon === 2 && this.localCoin < 10) {\n        uni.showToast({\n          title: '子弹不足10发',\n          icon: 'none',\n          duration: 1500\n        })\n        return false\n      }\n      return true\n    },\n    // 发射子弹前检查弹药，发射子弹并乐观扣除消耗，支持多种武器类型\n    async fire () {\n      const time = Date.now()\n      if (time - this.lastShotTime < this.fireCooldown) {\n        return\n      }\n      this.lastShotTime = time\n\n      // 检查是否可以发射\n      if (!await this.checkAndFire()) return\n\n      if (this.localCoin <= 0) {\n        uni.showToast({\n          title: '子弹不足',\n          icon: 'none',\n          duration: 1500\n        })\n        return\n      }\n\n      // 计算连发加成\n      const now = Date.now()\n      let rapidFireMultiplier = 1\n      if (now - this.lastFireTime < this.rapidFireWindow) {\n        rapidFireMultiplier += this.rapidFireBonus\n      }\n      this.lastFireTime = now\n\n      // 计算当前发射消耗\n      let bulletCost = 1\n      if (this.currentWeapon === 3) {\n        bulletCost = 3\n      } else if (this.currentWeapon === 2) {\n        bulletCost = 10\n      }\n\n      // 检查子弹是否足够\n      if (this.localCoin < bulletCost) {\n        uni.showToast({\n          title: '子弹不足',\n          icon: 'none',\n          duration: 1500\n        })\n        return\n      }\n\n      // 直接扣除本地子弹\n      this.localCoin -= bulletCost\n      // 更新本地缓存\n      uni.setStorageSync(this.siteBaseUrl + '_localCoin', {\n        count: this.localCoin,\n        updatedAt: Date.now()\n      })\n\n      // 播放音效\n      // this.playSound('shoot')\n\n      // 创建子弹\n      if (this.currentWeapon === 2) {\n        this.createLaserBullet(rapidFireMultiplier)\n      } else if (this.currentWeapon === 3) {\n        this.createShotgunBullets(rapidFireMultiplier)\n      } else {\n        this.createNormalBullet(rapidFireMultiplier)\n      }\n    },\n    createNormalBullet (rapidFireMultiplier = 1) {\n      const normalBulletCount = this.bullets.filter(b => b.type === 'normal').length;\n      if (normalBulletCount >= this.maxBullets) return;\n\n      const bullet = this.getFromPool('bullets');\n      Object.assign(bullet, {\n        x: Math.floor(this.gameArea.width / 2),\n        y: this.gameArea.height - 100,\n        angle: this.cannonAngle,\n        speed: this.bulletSpeeds.normal,\n        damage: this.calculateDamage() * this.bulletDamages.normal * rapidFireMultiplier,\n        type: 'normal-bullet',\n        width: 20,\n        height: 20,\n        hitCount: 0,\n        rapidFireMultiplier,\n        targetFish: this.targetFish,\n        startX: Math.floor(this.gameArea.width / 2),\n        startY: this.gameArea.height - 100\n      });\n      this.bullets.push(bullet);\n      this.playSound('shoot');\n    },\n    createLaserBullet (rapidFireMultiplier = 1) {\n      const laserCount = this.bullets.filter(b => b.type === 'laser').length;\n      if (laserCount >= 3) return;\n\n      const bullet = this.getFromPool('bullets');\n      // 修改激光炮的初始位置计算\n      const cannonX = Math.floor(this.gameArea.width / 2);\n      const cannonY = this.gameArea.height - 100; // 调整发射位置\n\n      Object.assign(bullet, {\n        x: cannonX,\n        y: cannonY,\n        angle: this.cannonAngle,\n        speed: this.bulletSpeeds.laser,\n        damage: this.calculateDamage() * this.bulletDamages.laser * rapidFireMultiplier,\n        type: 'laser',\n        width: 40, // 增加宽度\n        height: 300,\n        pierceCount: 3,\n        hitCount: 0,\n        rapidFireMultiplier,\n        targetFish: this.targetFish,\n        lastUpdate: performance.now()\n      });\n      this.bullets.push(bullet);\n\n      setTimeout(() => {\n        this.playSound('laser');\n      }, 50);\n    },\n    createShotgunBullets (rapidFireMultiplier = 1) {\n      [-1, 0, 1].forEach((offset, idx) => {\n        setTimeout(() => {\n          const bullet = this.getFromPool('bullets');\n          Object.assign(bullet, {\n            x: Math.floor(this.gameArea.width / 2),\n            y: this.gameArea.height - 100,\n            angle: this.cannonAngle + (offset * 15),\n            speed: this.bulletSpeeds.shotgun,\n            damage: this.calculateDamage() * this.bulletDamages.shotgun * rapidFireMultiplier,\n            type: 'shotgun',\n            width: 15,\n            height: 15,\n            hitCount: 0,\n            rapidFireMultiplier,\n            targetFish: this.targetFish\n          });\n          this.bullets.push(bullet);\n        }, idx * 100);\n      });\n      this.playSound('laser_2');\n    },\n    // 计算伤害值\n    calculateDamage () {\n      // 基础伤害值\n      let baseDamage = 10;\n\n      // 根据当前武器类型调整伤害\n      switch (this.currentWeapon) {\n        case 1: // 普通炮\n          baseDamage = 10;\n          break;\n        case 2: // 激光炮\n          baseDamage = 15;\n          break;\n        case 3: // 散弹炮\n          baseDamage = 6;\n          break;\n      }\n\n      // 计算连续发射加成\n      const consecutiveBonus = this.consecutiveShots > 1 ?\n        (1 + (this.consecutiveShots - 1) * this.consecutiveBonus) : 1;\n\n      // 计算最终伤害\n      const finalDamage = Math.floor(baseDamage * consecutiveBonus);\n\n      return finalDamage;\n    },\n    /* ==================== 碰撞检测方法 ==================== */\n    // 通过简单圆碰撞检测子弹和鱼是否接触，触发击中特效和逻辑\n    checkCollision (bullet) {\n      const now = performance.now();\n      if (now - this.collisionBox.lastCheckTime < this.collisionBox.checkInterval) {\n        return false;\n      }\n      this.collisionBox.lastCheckTime = now;\n\n      const bulletX = bullet.x;\n      const bulletY = bullet.y;\n\n      // 如果是激光炮，调整碰撞检测逻辑\n      if (bullet.type === 'laser') {\n        // 计算激光炮的实际碰撞区域\n        const laserLength = 300; // 激光长度\n        const laserWidth = 60; // 增加激光宽度以提高命中率\n        const rad = (bullet.angle * Math.PI) / 180;\n\n        // 计算激光的终点\n        const endX = bulletX + Math.sin(rad) * laserLength;\n        const endY = bulletY - Math.cos(rad) * laserLength;\n\n        // 检查目标鱼\n        if (bullet.targetFish && !bullet.targetFish.isCaught) {\n          const fish = bullet.targetFish;\n          const fishCenterX = fish.x + (fish.width || 120);\n          const fishCenterY = fish.y + (fish.height || 120);\n\n          // 计算鱼到激光线的距离\n          const distance = this.pointToLineDistance(\n            fishCenterX, fishCenterY,\n            bulletX, bulletY,\n            endX, endY\n          );\n\n          // 如果距离小于激光宽度，则发生碰撞\n          if (distance < laserWidth) {\n            return this.handleBulletHit(bullet, fish, fishCenterX, fishCenterY);\n          }\n        }\n\n        // 检查其他鱼\n        for (let i = 0; i < this.fishList.length; i++) {\n          const fish = this.fishList[i];\n          if (fish.isCaught || fish === bullet.targetFish) continue;\n\n          const fishCenterX = fish.x + (fish.width || 120);\n          const fishCenterY = fish.y + (fish.height || 120);\n\n          // 计算鱼到激光线的距离\n          const distance = this.pointToLineDistance(\n            fishCenterX, fishCenterY,\n            bulletX, bulletY,\n            endX, endY\n          );\n\n          // 如果距离小于激光宽度，则发生碰撞\n          if (distance < laserWidth) {\n            return this.handleBulletHit(bullet, fish, fishCenterX, fishCenterY);\n          }\n        }\n      } else {\n        // 原有的碰撞检测逻辑保持不变\n        if (bullet.targetFish && !bullet.targetFish.isCaught) {\n          const fish = bullet.targetFish;\n          const fishCenterX = fish.x + (fish.width || 120);\n          const fishCenterY = fish.y + (fish.height || 120);\n\n          const dx = fishCenterX - bulletX;\n          const dy = fishCenterY - bulletY;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance < this.collisionBox.fishWidth) {\n            return this.handleBulletHit(bullet, fish, bulletX, bulletY);\n          }\n        }\n\n        for (let i = 0; i < this.fishList.length; i++) {\n          const fish = this.fishList[i];\n          if (fish.isCaught || fish === bullet.targetFish) continue;\n\n          const fishCenterX = fish.x + (fish.width || 120);\n          const fishCenterY = fish.y + (fish.height || 120);\n\n          const dx = fishCenterX - bulletX;\n          const dy = fishCenterY - bulletY;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n\n          if (distance < this.collisionBox.fishWidth) {\n            return this.handleBulletHit(bullet, fish, bulletX, bulletY);\n          }\n        }\n      }\n      return false;\n    },\n\n    // 添加点到线段距离的计算方法\n    pointToLineDistance (x, y, x1, y1, x2, y2) {\n      const A = x - x1;\n      const B = y - y1;\n      const C = x2 - x1;\n      const D = y2 - y1;\n\n      const dot = A * C + B * D;\n      const len_sq = C * C + D * D;\n      let param = -1;\n\n      if (len_sq !== 0) {\n        param = dot / len_sq;\n      }\n\n      let xx, yy;\n\n      if (param < 0) {\n        xx = x1;\n        yy = y1;\n      } else if (param > 1) {\n        xx = x2;\n        yy = y2;\n      } else {\n        xx = x1 + param * C;\n        yy = y1 + param * D;\n      }\n\n      const dx = x - xx;\n      const dy = y - yy;\n\n      return Math.sqrt(dx * dx + dy * dy);\n    },\n\n    // 添加子弹命中处理方法\n    handleBulletHit (bullet, fish, bulletX, bulletY) {\n      const now = Date.now();\n      // 检查是否连续命中\n      if (now - this.lastHitTime < 1000) {\n        this.consecutiveHits++;\n      } else {\n        this.consecutiveHits = 1;\n      }\n      this.lastHitTime = now;\n\n      // 触发连续爆闪效果\n      if (fish.isSelected) {\n        let flashCount = 0;\n        const flashInterval = setInterval(() => {\n          if (flashCount >= this.hitEffectConfig.flashCount) {\n            clearInterval(flashInterval);\n            fish.isHit = false;\n            return;\n          }\n          fish.isHit = true;\n          setTimeout(() => {\n            fish.isHit = false;\n          }, this.hitEffectConfig.flashDuration);\n          flashCount++;\n        }, this.hitEffectConfig.flashInterval);\n      }\n\n      // 计算连续命中加成\n      const consecutiveBonus = 1 + (this.consecutiveHits - 1) * this.consecutiveHitBonus;\n\n      const realRate = fish.real_rate || 100;\n      let baseDamagePercent = 0.1;\n      let damageEffectFn = null;\n      let damageMultiplier = 1;\n\n      // 测试员逻辑：level为1必中\n      if (this.handleTestHit()) {\n        baseDamagePercent = 1; // 设置100%伤害\n        damageMultiplier = 999; // 设置极高的伤害倍率\n      } else {\n        // 初始化射击计数\n        if (!fish.shotCount) {\n          fish.shotCount = 0;\n        }\n        fish.shotCount++;\n\n        // 根据子弹类型计算伤害\n        switch (bullet.type) {\n          case 'normal-bullet':\n            if (fish.shotCount <= this.hpConfig.initialShotsCount) {\n              const remainingHp = fish.currentHp / fish.originalHp * 100;\n              const targetHp = this.hpConfig.initialDamageTarget;\n\n              if (remainingHp <= targetHp) {\n                const hitChance = realRate / 100;\n                // 低概率时更容易出现不掉血或极小伤害\n                if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.4)) {\n                  // 未命中时，有80%概率不掉血，20%概率造成极小伤害\n                  baseDamagePercent = Math.random() > 0.8 ? 0.0001 : 0;\n                } else {\n                  // 根据real_rate计算伤害范围，使用更平滑的曲线\n                  let damageRange;\n                  if (realRate <= 10) {\n                    // 低概率时，伤害范围更小且更均匀\n                    const baseDamage = 0.0002 + (realRate / 50000); // 基础伤害随概率缓慢增加\n                    const randomFactor = Math.random() * 0.0003; // 随机波动范围\n                    baseDamagePercent = baseDamage + randomFactor;\n                  } else {\n                    // 高概率时保持原有逻辑\n                    const normalMin = 0.02;\n                    const normalMax = 0.02 + (realRate / 1250);\n                    baseDamagePercent = normalMin + Math.random() * (normalMax - normalMin);\n                  }\n                  // 伤害倍率也使用更平滑的曲线\n                  damageMultiplier = realRate <= 10 ?\n                    1 + (realRate / 1000) : // 低概率时倍率增长更慢\n                    1 + (realRate / 80);\n                }\n              } else {\n                const damageNeeded = remainingHp - targetHp;\n                baseDamagePercent = (damageNeeded / 100) / (this.hpConfig.initialShotsCount - fish.shotCount + 1);\n                baseDamagePercent *= (1 + this.hpConfig.initialDamageBonus);\n              }\n            } else {\n              const hitChance = realRate / 100;\n              if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.4)) {\n                baseDamagePercent = Math.random() > 0.8 ? 0.0001 : 0;\n              } else {\n                let damageRange;\n                if (realRate <= 10) {\n                  const baseDamage = 0.0002 + (realRate / 50000);\n                  const randomFactor = Math.random() * 0.0003;\n                  baseDamagePercent = baseDamage + randomFactor;\n                } else {\n                  const normalMin = 0.02;\n                  const normalMax = 0.02 + (realRate / 1250);\n                  baseDamagePercent = normalMin + Math.random() * (normalMax - normalMin);\n                }\n                damageMultiplier = realRate <= 10 ?\n                  1 + (realRate / 1000) :\n                  1 + (realRate / 80);\n              }\n            }\n            damageEffectFn = () => this.addHitEffect(bulletX, bulletY);\n            break;\n          case 'laser':\n            if (fish.shotCount <= this.hpConfig.initialShotsCount) {\n              const remainingHp = fish.currentHp / fish.originalHp * 100;\n              const targetHp = this.hpConfig.initialDamageTarget;\n\n              if (remainingHp <= targetHp) {\n                const hitChance = realRate / 100;\n                if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.4)) {\n                  baseDamagePercent = Math.random() > 0.8 ? 0.0001 : 0;\n                } else {\n                  if (realRate <= 10) {\n                    // 激光炮在低概率时伤害略高于普通子弹\n                    const baseDamage = 0.0003 + (realRate / 40000);\n                    const randomFactor = Math.random() * 0.0004;\n                    baseDamagePercent = baseDamage + randomFactor;\n                  } else {\n                    const laserMin = 0.025;\n                    const laserMax = 0.025 + (realRate / 1000);\n                    baseDamagePercent = laserMin + Math.random() * (laserMax - laserMin);\n                  }\n                  damageMultiplier = realRate <= 10 ?\n                    1.2 + (realRate / 1000) :\n                    1.2 + (realRate / 60);\n                }\n              } else {\n                const damageNeeded = remainingHp - targetHp;\n                baseDamagePercent = (damageNeeded / 100) / (this.hpConfig.initialShotsCount - fish.shotCount + 1);\n                baseDamagePercent *= (1 + this.hpConfig.initialDamageBonus);\n              }\n            } else {\n              const hitChance = realRate / 100;\n              if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.4)) {\n                baseDamagePercent = Math.random() > 0.8 ? 0.0001 : 0;\n              } else {\n                if (realRate <= 10) {\n                  const baseDamage = 0.0003 + (realRate / 40000);\n                  const randomFactor = Math.random() * 0.0004;\n                  baseDamagePercent = baseDamage + randomFactor;\n                } else {\n                  const laserMin = 0.025;\n                  const laserMax = 0.025 + (realRate / 1000);\n                  baseDamagePercent = laserMin + Math.random() * (laserMax - laserMin);\n                }\n                damageMultiplier = realRate <= 10 ?\n                  1.2 + (realRate / 1000) :\n                  1.2 + (realRate / 60);\n              }\n            }\n            damageEffectFn = () => this.addExplosionEffect(bulletX, bulletY, 1.2);\n            break;\n          case 'shotgun':\n            if (fish.shotCount <= this.hpConfig.initialShotsCount) {\n              const remainingHp = fish.currentHp / fish.originalHp * 100;\n              const targetHp = this.hpConfig.initialDamageTarget;\n\n              if (remainingHp <= targetHp) {\n                const hitChance = realRate / 100;\n                if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.4)) {\n                  baseDamagePercent = Math.random() > 0.8 ? 0.0001 : 0;\n                } else {\n                  if (realRate <= 10) {\n                    // 散弹炮在低概率时伤害略低于普通子弹\n                    const baseDamage = 0.00015 + (realRate / 60000);\n                    const randomFactor = Math.random() * 0.00025;\n                    baseDamagePercent = baseDamage + randomFactor;\n                  } else {\n                    const shotgunMin = 0.015;\n                    const shotgunMax = 0.015 + (realRate / 1500);\n                    baseDamagePercent = shotgunMin + Math.random() * (shotgunMax - shotgunMin);\n                  }\n                  damageMultiplier = realRate <= 10 ?\n                    1 + (realRate / 1000) :\n                    1 + (realRate / 90);\n                }\n              } else {\n                const damageNeeded = remainingHp - targetHp;\n                baseDamagePercent = (damageNeeded / 100) / (this.hpConfig.initialShotsCount - fish.shotCount + 1);\n                baseDamagePercent *= (1 + this.hpConfig.initialDamageBonus);\n              }\n            } else {\n              const hitChance = realRate / 100;\n              if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.4)) {\n                baseDamagePercent = Math.random() > 0.8 ? 0.0001 : 0;\n              } else {\n                if (realRate <= 10) {\n                  const baseDamage = 0.00015 + (realRate / 60000);\n                  const randomFactor = Math.random() * 0.00025;\n                  baseDamagePercent = baseDamage + randomFactor;\n                } else {\n                  const shotgunMin = 0.015;\n                  const shotgunMax = 0.015 + (realRate / 1500);\n                  baseDamagePercent = shotgunMin + Math.random() * (shotgunMax - shotgunMin);\n                }\n                damageMultiplier = realRate <= 10 ?\n                  1 + (realRate / 1000) :\n                  1 + (realRate / 90);\n              }\n            }\n            damageEffectFn = () => this.addExplosionEffect(bulletX, bulletY, 1);\n            break;\n          case 'laser':\n            // 激光炮也使用前10发子弹规则\n            if (fish.shotCount <= this.hpConfig.initialShotsCount) {\n              // 前10发子弹使用固定伤害计算\n              const remainingHp = fish.currentHp / fish.originalHp * 100;\n              const targetHp = this.hpConfig.initialDamageTarget;\n\n              // 如果当前血量已经低于目标血量，使用真实概率计算\n              if (remainingHp <= targetHp) {\n                // 根据real_rate计算命中概率\n                const hitChance = realRate / 100;\n                if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.3)) {\n                  // 未命中，造成极小伤害\n                  baseDamagePercent = Math.random() > 0.7 ? 0.0001 : 0;\n                } else {\n                  // 命中，造成正常伤害\n                  const laserMin = realRate <= 10 ? 0.0003 : 0.025;\n                  const laserMax = realRate <= 10 ? 0.0003 + (realRate / 2000) : 0.025 + (realRate / 500);\n                  baseDamagePercent = laserMin + Math.random() * (laserMax - laserMin);\n                  damageMultiplier = realRate <= 10 ? 1.2 + (realRate / 1000) : 1.2 + (realRate / 50);\n                }\n              } else {\n                // 计算需要造成的伤害\n                const damageNeeded = remainingHp - targetHp;\n                baseDamagePercent = (damageNeeded / 100) / (this.hpConfig.initialShotsCount - fish.shotCount + 1);\n                baseDamagePercent *= (1 + this.hpConfig.initialDamageBonus);\n              }\n            } else {\n              // 后续子弹使用真实概率计算\n              const hitChance = realRate / 100;\n              if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.3)) {\n                baseDamagePercent = Math.random() > 0.7 ? 0.0001 : 0;\n              } else {\n                const laserMin = realRate <= 10 ? 0.0003 : 0.025;\n                const laserMax = realRate <= 10 ? 0.0003 + (realRate / 2000) : 0.025 + (realRate / 500);\n                baseDamagePercent = laserMin + Math.random() * (laserMax - laserMin);\n                damageMultiplier = realRate <= 10 ? 1.2 + (realRate / 1000) : 1.2 + (realRate / 50);\n              }\n            }\n            damageEffectFn = () => this.addExplosionEffect(bulletX, bulletY, 1.2);\n            break;\n          case 'shotgun':\n            // 散弹炮也使用前10发子弹规则\n            if (fish.shotCount <= this.hpConfig.initialShotsCount) {\n              // 前10发子弹使用固定伤害计算\n              const remainingHp = fish.currentHp / fish.originalHp * 100;\n              const targetHp = this.hpConfig.initialDamageTarget;\n\n              // 如果当前血量已经低于目标血量，使用真实概率计算\n              if (remainingHp <= targetHp) {\n                // 根据real_rate计算命中概率\n                const hitChance = realRate / 100;\n                if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.3)) {\n                  // 未命中，造成极小伤害\n                  baseDamagePercent = Math.random() > 0.7 ? 0.0001 : 0;\n                } else {\n                  // 命中，造成正常伤害\n                  const shotgunMin = realRate <= 10 ? 0.0003 : 0.01;\n                  const shotgunMax = realRate <= 10 ? 0.0003 + (realRate / 3000) : 0.01 + (realRate / 1500);\n                  baseDamagePercent = shotgunMin + Math.random() * (shotgunMax - shotgunMin);\n                  damageMultiplier = realRate <= 10 ? 1 + (realRate / 200) : 1 + (realRate / 100);\n                }\n              } else {\n                // 计算需要造成的伤害\n                const damageNeeded = remainingHp - targetHp;\n                baseDamagePercent = (damageNeeded / 100) / (this.hpConfig.initialShotsCount - fish.shotCount + 1);\n                baseDamagePercent *= (1 + this.hpConfig.initialDamageBonus);\n              }\n            } else {\n              // 后续子弹使用真实概率计算\n              const hitChance = realRate / 100;\n              if (Math.random() > hitChance || (realRate <= 10 && Math.random() > 0.3)) {\n                baseDamagePercent = Math.random() > 0.7 ? 0.0001 : 0;\n              } else {\n                const shotgunMin = realRate <= 10 ? 0.0003 : 0.01;\n                const shotgunMax = realRate <= 10 ? 0.0003 + (realRate / 3000) : 0.01 + (realRate / 1500);\n                baseDamagePercent = shotgunMin + Math.random() * (shotgunMax - shotgunMin);\n                damageMultiplier = realRate <= 10 ? 1 + (realRate / 200) : 1 + (realRate / 100);\n              }\n            }\n            damageEffectFn = () => this.addExplosionEffect(bulletX, bulletY, 1);\n            break;\n        }\n      }\n\n      // 播放击中特效\n      if (damageEffectFn) damageEffectFn();\n\n      // 计算实际伤害（加入连续命中加成和连发加成）\n      let adjustedDamagePercent = baseDamagePercent * damageMultiplier * consecutiveBonus * (bullet.rapidFireMultiplier || 1);\n\n      const damage = fish.originalHp * adjustedDamagePercent;\n\n      // 减血并保留两位小数\n      fish.currentHp = Math.max(0, Math.round((fish.currentHp - damage) * 100) / 100);\n\n      // 检查是否需要显示警告\n      const hpPercentage = (fish.currentHp / fish.originalHp) * 100;\n      if (hpPercentage <= this.hpConfig.warningThreshold && !this.warnedFishIds.has(fish.id)) {\n        this.showHpWarning(fish);\n        this.warnedFishIds.add(fish.id);\n      }\n\n      // 更新血条缓存\n      this.updateLocalHp(fish);\n\n      // 捕获判断\n      if (fish.currentHp <= 0 && !fish._isCaughtTemp) {\n        fish.isCaught = true;\n\n        // 检查是否是炸弹鱼\n        if (fish.type == 4) {\n          this.handleBombExplosion(fish);\n          return;\n        }\n\n        this.checkRealHit(fish);\n      }\n\n      // 增加命中计数\n      bullet.hitCount++;\n\n      // 根据子弹类型决定是否移除\n      if (bullet.type === 'laser') {\n        if (bullet.hitCount >= bullet.pierceCount) {\n          return true; // 移除子弹\n        }\n      } else {\n        return true; // 普通子弹和散弹直接移除\n      }\n      return false;\n    },\n\n    /* ==================== 特效系统方法 ==================== */\n    // 从特效池获取特效对象\n    getEffectFromPool () {\n      let effect = this.hitEffectConfig.effectPool.find(e => !e.active);\n      if (!effect) {\n        effect = {\n          id: Date.now() + Math.random().toString(36).substr(2, 9),\n          x: 0,\n          y: 0,\n          scale: 1,\n          opacity: 1,\n          particles: [],\n          active: false,\n          lifeTime: 0\n        };\n        this.hitEffectConfig.effectPool.push(effect);\n      }\n      return effect;\n    },\n\n    // 重置特效对象\n    resetEffect (effect) {\n      effect.x = 0;\n      effect.y = 0;\n      effect.scale = 1;\n      effect.opacity = 1;\n      effect.particles = [];\n      effect.active = false;\n      effect.lifeTime = 0;\n      return effect;\n    },\n\n    // 修改添加击中效果方法\n    addHitEffect (x, y) {\n      // 检查当前活跃特效数量\n      const activeEffects = this.hitEffects.filter(e => e.active).length;\n      if (activeEffects >= this.hitEffectConfig.maxEffects) {\n        return; // 如果达到最大数量，直接返回\n      }\n\n      const effect = this.getEffectFromPool();\n      effect.x = x;\n      effect.y = y;\n      effect.active = true;\n      effect.lifeTime = 300; // 设置生命周期\n\n      // 创建粒子效果\n      for (let i = 0; i < 6; i++) {\n        const angle = i * 60;\n        const particle = {\n          id: `${effect.id}-${i}`,\n          x: x,\n          y: y,\n          angle: angle,\n          scale: 1,\n          opacity: 1\n        };\n        effect.particles.push(particle);\n      }\n\n      // 添加到活跃特效列表\n      this.hitEffects.push(effect);\n\n      // 动画效果\n      setTimeout(() => {\n        effect.scale = 1.5;\n        effect.opacity = 0;\n        effect.particles.forEach(particle => {\n          particle.scale = 0;\n          particle.opacity = 0;\n        });\n      }, 50);\n\n      // 移除效果\n      setTimeout(() => {\n        const index = this.hitEffects.findIndex(e => e.id === effect.id);\n        if (index !== -1) {\n          this.hitEffects.splice(index, 1);\n          this.resetEffect(effect);\n        }\n      }, 300);\n    },\n\n    // 修改添加爆炸效果方法\n    addExplosionEffect (x, y, size = 1) {\n      // 检查当前活跃特效数量\n      const activeEffects = this.hitEffects.filter(e => e.active).length;\n      if (activeEffects >= this.hitEffectConfig.maxEffects) {\n        return; // 如果达到最大数量，直接返回\n      }\n\n      const effect = this.getEffectFromPool();\n      effect.x = x;\n      effect.y = y;\n      effect.active = true;\n      effect.lifeTime = 300;\n\n      // 创建粒子效果\n      const particleCount = Math.floor(8 * size);\n      for (let i = 0; i < particleCount; i++) {\n        const angle = i * (360 / particleCount);\n        const particle = {\n          id: `${effect.id}-${i}`,\n          x: x,\n          y: y,\n          angle: angle,\n          scale: 1,\n          opacity: 1\n        };\n        effect.particles.push(particle);\n      }\n\n      // 添加到活跃特效列表\n      this.hitEffects.push(effect);\n\n      // 动画效果\n      setTimeout(() => {\n        effect.scale = 2 * size;\n        effect.opacity = 0;\n        effect.particles.forEach(particle => {\n          particle.scale = 0;\n          particle.opacity = 0;\n        });\n      }, 50);\n\n      // 移除效果\n      setTimeout(() => {\n        const index = this.hitEffects.findIndex(e => e.id === effect.id);\n        if (index !== -1) {\n          this.hitEffects.splice(index, 1);\n          this.resetEffect(effect);\n        }\n      }, 300);\n    },\n\n    // 修改更新特效方法\n    updateEffects (deltaTime) {\n      for (let i = this.hitEffects.length - 1; i >= 0; i--) {\n        const effect = this.hitEffects[i];\n        effect.lifeTime -= deltaTime;\n\n        if (effect.lifeTime <= 0) {\n          this.resetEffect(effect);\n          this.hitEffects.splice(i, 1);\n        }\n      }\n    },\n\n    // 添加捕获动画方法\n    showCatchAnimation (fish) {\n      // 创建捕获动画效果\n      const catchEffect = {\n        id: Date.now(),\n        x: fish.x,\n        y: fish.y,\n        scale: 1,\n        opacity: 1\n      };\n\n      this.hitEffects.push(catchEffect);\n\n      // 动画效果\n      requestAnimationFrame(() => {\n        catchEffect.scale = 2;\n        catchEffect.opacity = 0;\n      });\n\n      // 移除效果\n      setTimeout(() => {\n        const index = this.hitEffects.findIndex(e => e.id === catchEffect.id);\n        if (index !== -1) {\n          this.hitEffects.splice(index, 1);\n        }\n      }, 500);\n    },\n    /* ==================== 炸弹系统方法 ==================== */\n    // 修改炸弹爆炸处理方法\n    handleBombExplosion (fish) {\n      // 播放爆炸音效\n      this.playSound('boom');\n\n      // 创建Canvas爆炸效果\n      this.createCanvasExplosion(fish.x + 120, fish.y + 120);\n\n      // 震动屏幕\n      uni.vibrateLong();\n\n      // 对周围鱼群造成范围伤害\n      this.dealAreaDamage(fish.x + 120, fish.y + 120);\n\n      // 重置炸弹状态\n      fish.currentHp = fish.originalHp;\n      fish.isCaught = false;\n      fish.isSelected = false;\n      fish._isCaughtTemp = false;\n      fish.x = this.gameArea.width + 100;\n      fish.y = this.gameArea.minY + Math.random() * (this.gameArea.maxY - this.gameArea.minY);\n    },\n    // 添加范围伤害处理方法\n    dealAreaDamage (centerX, centerY) {\n      const { explosionRadius, maxDamagePercent, minDamagePercent } = this.bombConfig;\n\n      this.fishList.forEach(fish => {\n        if (fish.isCaught || fish._isCaughtTemp) return;\n\n        // 计算鱼到爆炸中心的距离\n        const fishCenterX = fish.x + 120;\n        const fishCenterY = fish.y + 120;\n        const dx = fishCenterX - centerX;\n        const dy = fishCenterY - centerY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // 如果在爆炸范围内\n        if (distance <= explosionRadius) {\n          // 根据距离计算伤害比例（距离越近伤害越大）\n          const damageRatio = maxDamagePercent - (distance / explosionRadius) * (maxDamagePercent - minDamagePercent);\n\n          // 计算实际伤害\n          const damage = fish.originalHp * damageRatio;\n\n          // 造成伤害\n          fish.currentHp = Math.max(0, fish.currentHp - damage);\n\n          // 创建伤害效果\n          this.addHitEffect(fishCenterX, fishCenterY);\n\n          // 如果鱼被击毁\n          if (fish.currentHp <= 0 && !fish._isCaughtTemp) {\n            fish.isCaught = true;\n            this.checkRealHit(fish);\n          }\n        }\n      });\n    },\n    // 添加炸弹爆炸特效\n    addBombExplosionEffect (x, y) {\n      const effectId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      const effect = {\n        id: effectId,\n        x: x,\n        y: y,\n        scale: 1,\n        opacity: 1,\n        particles: [],\n        type: 'bomb'\n      };\n\n      // 创建爆炸效果\n      this.hitEffects.push(effect);\n\n      // 创建更多的粒子效果\n      const particleCount = 16; // 增加粒子数量\n      for (let i = 0; i < particleCount; i++) {\n        const angle = (i * 360) / particleCount;\n        const particle = {\n          id: `${effectId}-${i}`,\n          x: x,\n          y: y,\n          angle: angle,\n          scale: 1,\n          opacity: 1,\n          distance: 0\n        };\n        effect.particles.push(particle);\n      }\n\n      // 动画效果\n      const duration = 1000; // 延长动画时间\n      const startTime = Date.now();\n\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // 爆炸效果缩放\n        effect.scale = 1 + progress * 3;\n        effect.opacity = 1 - progress;\n\n        // 更新粒子\n        effect.particles.forEach(particle => {\n          particle.distance = progress * 200; // 增加扩散距离\n          particle.scale = 1 - progress;\n          particle.opacity = 1 - progress;\n        });\n\n        // 强制更新视图\n        this.$forceUpdate();\n\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        } else {\n          // 移除效果\n          const index = this.hitEffects.findIndex(e => e.id === effect.id);\n          if (index !== -1) {\n            this.hitEffects.splice(index, 1);\n          }\n        }\n      };\n      requestAnimationFrame(animate);\n    },\n    // 添加冲击波效果方法\n    createShockwave (x, y) {\n      const shockwave = {\n        id: `shockwave-${Date.now()}`,\n        x: x,\n        y: y,\n        scale: 0,\n        opacity: 1\n      };\n\n      this.hitEffects.push(shockwave);\n\n      // 冲击波动画\n      const duration = 800;\n      const startTime = Date.now();\n\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        // 冲击波扩散\n        shockwave.scale = progress * 4;\n        shockwave.opacity = 1 - progress;\n\n        // 强制更新视图\n        this.$forceUpdate();\n\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        } else {\n          // 移除效果\n          const index = this.hitEffects.findIndex(e => e.id === shockwave.id);\n          if (index !== -1) {\n            this.hitEffects.splice(index, 1);\n          }\n        }\n      };\n      requestAnimationFrame(animate);\n    },\n    // 添加爆炸粒子效果方法\n    createExplosionParticles (x, y) {\n      const particleCount = 30; // 增加粒子数量\n      const particles = [];\n\n      for (let i = 0; i < particleCount; i++) {\n        const angle = (i * 360) / particleCount;\n        const speed = 2 + Math.random() * 3;\n        const size = 10 + Math.random() * 20;\n        const particle = {\n          id: `particle-${Date.now()}-${i}`,\n          x: x,\n          y: y,\n          size: size,\n          angle: angle,\n          speed: speed,\n          opacity: 1,\n          scale: 1\n        };\n        particles.push(particle);\n        this.hitEffects.push(particle);\n      }\n\n      // 粒子动画\n      const duration = 1000;\n      const startTime = Date.now();\n\n      const animate = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n\n        particles.forEach(particle => {\n          // 更新位置\n          const rad = (particle.angle * Math.PI) / 180;\n          particle.x += Math.cos(rad) * particle.speed * 5;\n          particle.y += Math.sin(rad) * particle.speed * 5;\n\n          // 更新大小和透明度\n          particle.scale = 1 - progress;\n          particle.opacity = 1 - progress;\n        });\n\n        // 强制更新视图\n        this.$forceUpdate();\n\n        if (progress < 1) {\n          requestAnimationFrame(animate);\n        } else {\n          // 移除所有粒子\n          particles.forEach(particle => {\n            const index = this.hitEffects.findIndex(e => e.id === particle.id);\n            if (index !== -1) {\n              this.hitEffects.splice(index, 1);\n            }\n          });\n        }\n      };\n\n      requestAnimationFrame(animate);\n    },\n    /* ==================== 空间划分系统方法 ==================== */\n    // 添加空间划分方法\n    initSpatialGrid () {\n      this.spatialGrid.grid = {};\n      this.updateSpatialGrid();\n    },\n    // 更新空间网格\n    updateSpatialGrid () {\n      // 清空网格\n      this.spatialGrid.grid = {};\n\n      // 将鱼放入对应网格\n      this.fishList.forEach(fish => {\n        if (fish.isCaught) return;\n\n        const cellX = Math.floor(fish.x / this.spatialGrid.cellSize);\n        const cellY = Math.floor(fish.y / this.spatialGrid.cellSize);\n        const cellKey = `${cellX},${cellY}`;\n\n        if (!this.spatialGrid.grid[cellKey]) {\n          this.spatialGrid.grid[cellKey] = [];\n        }\n        this.spatialGrid.grid[cellKey].push(fish);\n      });\n    },\n    // 获取子弹所在网格及其周围网格的鱼\n    getNearbyFish (bullet) {\n      const cellX = Math.floor(bullet.x / this.spatialGrid.cellSize);\n      const cellY = Math.floor(bullet.y / this.spatialGrid.cellSize);\n      const nearbyFish = new Set();\n\n      // 检查3x3网格区域\n      for (let dx = -1; dx <= 1; dx++) {\n        for (let dy = -1; dy <= 1; dy++) {\n          const cellKey = `${cellX + dx},${cellY + dy}`;\n          const fishInCell = this.spatialGrid.grid[cellKey] || [];\n          fishInCell.forEach(fish => nearbyFish.add(fish));\n        }\n      }\n\n      return Array.from(nearbyFish);\n    },\n    // 添加自动瞄准功能\n    autoAimBullet (bullet) {\n      if (!bullet.targetFish || bullet.targetFish.isCaught) return;\n\n      const fish = bullet.targetFish;\n      const fishCenterX = fish.x + 120;\n      const fishCenterY = fish.y + 120;\n\n      // 计算子弹到目标鱼的距离\n      const dx = fishCenterX - bullet.x;\n      const dy = fishCenterY - bullet.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // 如果距离小于阈值，进行自动瞄准\n      if (distance < this.spatialGrid.autoAimThreshold) {\n        // 计算目标角度\n        const targetAngle = Math.atan2(dx, -dy) * (180 / Math.PI);\n\n        // 平滑过渡到目标角度\n        const angleDiff = targetAngle - bullet.angle;\n        // 减小角度变化速度，使移动更平滑\n        bullet.angle += angleDiff * (this.spatialGrid.autoAimStrength * 0.5);\n      }\n    },\n    /* ==================== 音频系统方法 ==================== */\n    // 初始化音频\n    initSounds () {\n      // 创建音频实例\n      this.sounds = {\n        shoot: uni.createInnerAudioContext(),\n        laser: uni.createInnerAudioContext(),\n        laser_2: uni.createInnerAudioContext(),\n        boom: uni.createInnerAudioContext(),\n        warning: uni.createInnerAudioContext()  // 添加警告音效实例\n      };\n\n      // 设置音频源\n      this.sounds.shoot.src = AUDIO_RESOURCES.shoot;\n      this.sounds.laser.src = AUDIO_RESOURCES.laser;\n      this.sounds.laser_2.src = AUDIO_RESOURCES.laser_2;\n      this.sounds.boom.src = AUDIO_RESOURCES.boom;\n      this.sounds.warning.src = AUDIO_RESOURCES.warning;  // 设置警告音效源\n\n      // 设置音频加载状态\n      this.isAudioLoaded = true;\n    },\n    // 播放音效\n    playSound (soundName) {\n      if (!this.isAudioLoaded || !this.sounds[soundName]) return;\n\n      // 重置音频并播放\n      this.sounds[soundName].stop();\n      this.sounds[soundName].play();\n    },\n    // 停止所有音效\n    stopAllSounds () {\n      Object.values(this.sounds).forEach(sound => {\n        if (sound) {\n          sound.stop();\n        }\n      });\n    },\n    // 销毁音频实例\n    destroySounds () {\n      Object.values(this.sounds).forEach(sound => {\n        if (sound) {\n          sound.destroy();\n        }\n      });\n      this.sounds = {};\n      this.isAudioLoaded = false;\n    },\n    /* ==================== 对象池方法 ==================== */\n    // 从对象池获取对象\n    getFromPool (poolType) {\n      const pool = this.objectPools[poolType];\n      let obj;\n\n      if (pool.pool.length > 0) {\n        obj = pool.pool.pop();\n      } else {\n        obj = pool.create();\n      }\n\n      pool.active.add(obj);\n      return obj;\n    },\n\n    // 将对象返回池中\n    returnToPool (poolType, obj) {\n      const pool = this.objectPools[poolType];\n      if (pool.active.has(obj)) {\n        pool.active.delete(obj);\n        if (pool.pool.length < pool.maxSize) {\n          pool.pool.push(pool.reset(obj));\n        }\n      }\n    },\n\n    // 清理对象池\n    clearPool (poolType) {\n      const pool = this.objectPools[poolType];\n      pool.pool = [];\n      pool.active.clear();\n    },\n\n    // 炸弹Canvas初始化方法\n    initExplosionCanvas () {\n      if (this.canvasReady) return;\n\n      try {\n        // 获取系统信息\n        const sysInfo = uni.getSystemInfoSync();\n        this.canvasWidth = sysInfo.windowWidth;\n        this.canvasHeight = sysInfo.windowHeight;\n\n        // 创建Canvas上下文\n        this.explosionCtx = uni.createCanvasContext('explosionCanvas', this);\n        this.canvasReady = true;\n\n        // console.log('Canvas initialized successfully');\n      } catch (error) {\n        // console.error('Canvas initialization error:', error);\n      }\n    },\n\n    // 修改创建爆炸效果方法\n    createCanvasExplosion (x, y) {\n      if (!this.canvasReady) {\n        // console.log('Canvas not ready, retrying...');\n        setTimeout(() => {\n          this.createCanvasExplosion(x, y);\n        }, 100);\n        return;\n      }\n\n      const particleCount = 50;\n      const particles = [];\n\n      for (let i = 0; i < particleCount; i++) {\n        const angle = (i / particleCount) * Math.PI * 2;\n        const speed = 2 + Math.random() * 3;\n        const size = 3 + Math.random() * 5;\n        const color = this.getRandomExplosionColor();\n\n        particles.push({\n          x,\n          y,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          size,\n          color,\n          alpha: 1,\n          life: 1\n        });\n      }\n\n      this.explosionParticles.push(...particles);\n      this.animateExplosion();\n    },\n\n    // 修改动画方法\n    animateExplosion () {\n      if (!this.canvasReady || !this.explosionCtx || this.explosionParticles.length === 0) return;\n\n      try {\n        // 清除画布\n        this.explosionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        // 更新和绘制粒子\n        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {\n          const p = this.explosionParticles[i];\n\n          p.x += p.vx;\n          p.y += p.vy;\n          p.vy += 0.1;\n          p.life -= 0.02;\n          p.alpha = p.life;\n\n          // 设置粒子样式\n          this.explosionCtx.setFillStyle(p.color);\n          this.explosionCtx.setGlobalAlpha(p.alpha);\n\n          // 绘制粒子\n          this.explosionCtx.beginPath();\n          this.explosionCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n          this.explosionCtx.fill();\n\n          if (p.life <= 0) {\n            this.explosionParticles.splice(i, 1);\n          }\n        }\n\n        // 应用绘制\n        this.explosionCtx.draw();\n\n        // 继续动画\n        if (this.explosionParticles.length > 0) {\n          requestAnimationFrame(() => this.animateExplosion());\n        }\n      } catch (error) {\n        // console.error('Animation error:', error);\n        this.explosionParticles = [];\n      }\n    },\n\n    // 修改获取随机爆炸颜色方法\n    getRandomExplosionColor () {\n      const colors = [\n        '#ff0000', // 红色\n        '#ff6600', // 橙色\n        '#ffcc00', // 黄色\n        '#ffffff'  // 白色\n      ];\n      return colors[Math.floor(Math.random() * colors.length)];\n    },\n    // 刷新游戏\n    async fresh (flag = 0) {\n      // 同步子弹\n      this.initGameState()\n\n      // 重置血条\n      this.resetLocalHp()\n\n      // 重置游戏状态\n      this.score = 0;\n      this.currentPower = this.maxPower;\n      this.consecutiveShots = 0;\n\n      // 清空子弹和效果\n      this.bullets = [];\n      this.hitEffects = [];\n      this.listData = []\n      this.fishList = []\n\n      // 重置鱼群\n      this.getList({ num: 1, size: 20 })\n\n      this.initSounds();\n\n      if (flag == 1) {\n        uni.showToast({\n          title: '游戏已刷新',\n          icon: 'success'\n        });\n      }\n\n      // 重置警告状态\n      this.resetWarningState();\n    },\n    /* ==================== 血条系统方法 ==================== */\n    // 初始化血条和子弹\n    initGameState () {\n      // const token = uni.getStorageSync('token');\n      // if (!token) {\n      //   uni.reLaunch({\n      //     url: '/pages/tabBar/index'\n      //   });\n      //   return;\n      // }\n\n      // 获取用户信息, 初始化用户血条和子弹\n      setTimeout(() => {\n        this.$store.dispatch('getUserInfo').then(res => {\n          if (res.code == 200) {\n            this.userInfo = res.data;\n\n            // 初始化血条\n            if (this.userInfo.id) {\n              const storageKey = this.siteBaseUrl + this.storageKeys.localHp + this.userInfo.id;\n              const cachedHp = uni.getStorageSync(storageKey);\n\n              if (cachedHp) {\n                // 更新所有鱼的血条状态\n                this.fishList.forEach(fish => {\n                  const fishHp = cachedHp[fish.id];\n                  if (fishHp) {\n                    fish.currentHp = fishHp.hp;\n                    fish.originalHp = fish.originalHp || fish.currentHp;\n                  }\n                });\n              }\n            }\n\n            // 初始化子弹\n            this.syncBullets();\n          }\n        });\n      }, 1000)\n\n    },\n\n    // 更新血条缓存\n    updateLocalHp (fish) {\n      if (!this.userInfo.id) return;\n\n      const storageKey = this.siteBaseUrl + this.storageKeys.localHp + this.userInfo.id;\n      const cachedHp = uni.getStorageSync(storageKey) || {};\n\n      cachedHp[fish.id] = {\n        hp: fish.currentHp,\n        updatedAt: Date.now()\n      };\n\n      uni.setStorageSync(storageKey, cachedHp);\n    },\n\n    // 重置血条\n    resetLocalHp () {\n      if (!this.userInfo.id) return;\n\n      const storageKey = this.siteBaseUrl + this.storageKeys.localHp + this.userInfo.id;\n      uni.removeStorageSync(storageKey);\n\n      // 重置所有鱼的血条\n      this.fishList.forEach(fish => {\n        fish.currentHp = fish.originalHp;\n      });\n    },\n\n    // 同步子弹\n    initLocalCoin () {\n      const token = uni.getStorageSync('token');\n      if (!token) {\n        // console.warn('未登录，跳过初始化');\n        uni.reLaunch({\n          url: '/pages/tabBar/index'\n        });\n        return;\n      }\n\n      this.$store.dispatch('getUserInfo').then(res => {\n        this.userInfo = res.data;\n        this.syncBullets(); // 主逻辑放到这里处理\n      });\n    },\n\n    // 显示血量警告\n    showHpWarning (fish) {\n      this.currentWarningFish = fish;\n      this.hpWarningShow = true;\n\n\n      // 播放警告音效\n      this.playSound('warning');\n    },\n\n    // 关闭血量警告\n    closeHpWarning () {\n      this.hpWarningShow = false;\n      this.currentWarningFish = null;\n    },\n\n    // 确认血量警告\n    confirmHpWarning () {\n      if (this.currentWarningFish) {\n        // 检查子弹是否足够\n        if (this.localCoin <= 0) {\n          this.bulletRechargeShow = true;\n          this.closeHpWarning();\n          return;\n        }\n\n        // 直接击爆当前鱼\n        this.currentWarningFish.currentHp = 0;\n        this.checkRealHit(this.currentWarningFish);\n      }\n      this.closeHpWarning();\n    },\n\n    // 重置警告状态\n    resetWarningState () {\n      this.warnedFishIds.clear();\n      this.hpWarningShow = false;\n      this.currentWarningFish = null;\n    },\n\n    // 添加格式化血条百分比的方法\n    formatHpPercentage (currentHp, originalHp) {\n      const percentage = (currentHp / originalHp) * 100;\n      if (percentage === 0 || percentage === 100) {\n        return Math.round(percentage);\n      }\n      return percentage.toFixed(2);\n    },\n  },\n\n}\n</script>\n\n<style lang='scss' scoped>\n@import \"./mixin/home-h5.scss\";\n</style>","import mod from \"-!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\mini-css-extract-plugin\\\\dist\\\\loader.js??ref--8-oneOf-1-0!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\css-loader\\\\dist\\\\cjs.js??ref--8-oneOf-1-1!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\loaders\\\\stylePostLoader.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--8-oneOf-1-2!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\postcss-loader\\\\src\\\\index.js??ref--8-oneOf-1-3!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\sass-loader\\\\dist\\\\cjs.js??ref--8-oneOf-1-4!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--8-oneOf-1-5!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\index.js??vue-loader-options!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\style.js!./home.vue?vue&type=style&index=0&id=28aa9427&lang=scss&scoped=true&\"; export default mod; export * from \"-!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\mini-css-extract-plugin\\\\dist\\\\loader.js??ref--8-oneOf-1-0!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\css-loader\\\\dist\\\\cjs.js??ref--8-oneOf-1-1!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\loaders\\\\stylePostLoader.js!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--8-oneOf-1-2!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\postcss-loader\\\\src\\\\index.js??ref--8-oneOf-1-3!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\sass-loader\\\\dist\\\\cjs.js??ref--8-oneOf-1-4!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\webpack-preprocess-loader\\\\index.js??ref--8-oneOf-1-5!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\vue-cli-plugin-uni\\\\packages\\\\vue-loader\\\\lib\\\\index.js??vue-loader-options!D:\\\\hbuilderx\\\\HBuilderX\\\\plugins\\\\uniapp-cli\\\\node_modules\\\\@dcloudio\\\\webpack-uni-mp-loader\\\\lib\\\\style.js!./home.vue?vue&type=style&index=0&id=28aa9427&lang=scss&scoped=true&\"","// extracted by mini-css-extract-plugin\n    if(module.hot) {\n      // 1749106705822\n      var cssReload = require(\"D:/hbuilderx/HBuilderX/plugins/uniapp-cli/node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"hmr\":true,\"publicPath\":\"/\",\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  "],"sourceRoot":""}